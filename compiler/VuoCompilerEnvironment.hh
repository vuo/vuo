/**
 * @file
 * VuoCompilerEnvironment interface.
 *
 * @copyright Copyright © 2012–2023 Kosada Incorporated.
 * This interface description may be modified and distributed under the terms of the GNU Lesser General Public License (LGPL) version 2 or later.
 * For more information, see https://vuo.org/license.
 */

#pragma once

#include "VuoFileUtilities.hh"
#include "VuoFileWatcher.hh"
#include "VuoModuleCacheManifest.hh"
class VuoCompiler;
class VuoCompilerGenericType;
class VuoCompilerIssues;
class VuoCompilerModule;
class VuoCompilerNodeClass;
class VuoCompilerType;
class VuoDirectedAcyclicGraph;
class VuoMakeDependencies;
class VuoModuleCache;
class VuoModuleCompilationQueue;
class VuoModuleInfo;
class VuoModuleInfoIterator;
class VuoNodeSet;

/**
 * A set of modules (node classes, types, libraries) and search paths at a certain level of scope.
 *
 * This class refers to the following independent levels of scope. Listed in order from broadest to narrowest:
 *
 *    - Built-in — Modules officially distributed with Vuo.
 *    - System — Modules installed in the System Modules folder.
 *    - User — Modules installed in the User Modules folder.
 *    - Composition-family — Modules installed in a composition's Modules folder.
 *    - Composition — Modules required to compile the current top-level composition.
 *
 * At each level of scope, the VuoCompiler has two kinds of modules:
 *
 *    - Original modules — Modules loaded from files.
 *    - Generated modules — Modules generated by the compiler. The generated modules at a level of scope
 *         are those required to load the original modules at that level of scope. Additionally,
 *         at the composition scope, the generated modules include those required to compile the
 *         top-level composition.
 *
 * Each combination of level of scope and kind of module comprises a VuoCompilerEnvironment.
 *
 * Modules at one level of scope can refer to modules at broader levels of scope.
 * For example, a node class at the system level can use types defined at the system level and/or
 * the built-in level.
 *
 * Within a level of scope, original modules can refer to generated modules and vice versa.
 *
 * The set of all modules and search paths available to a VuoCompiler instance consists of all of its
 * VuoCompilerEnvironment instances layered on top of one another (like CSS). If a module of the same key
 * exists at multiple levels, the one at the narrowest level of scope is used.
 *
 * All functions in this class, unless otherwise specified, need to be called on `VuoCompiler::environmentQueue`.
 */
class VuoCompilerEnvironment : public VuoFileWatcherDelegate
{
private:
	string target;  ///< The LLVM target triple this environment uses.
	bool builtIn;  ///< True if this environment is for the built-in level of scope, false otherwise.
	bool generated;  ///< True if this environment is for generated modules, false if for original modules.
	set<VuoCompiler *> compilersToNotify;  ///< The compilers that this environment notifies when it loads/unloads modules as a result of changes to the watched search paths.
	dispatch_queue_t compilersToNotifyQueue;  ///< Synchronizes access to `compilersToNotify`.
	set<VuoFileWatcher *> moduleSearchPathWatchers;  ///< Dispatch sources watching module search paths for changes.
	map<string, VuoCompilerNodeClass *> nodeClasses;  ///< Node classes loaded, plus specialized node classes generated by the compiler.
	map<string, VuoCompilerType *> types;  ///< Types loaded.
	map<string, VuoNodeSet *> nodeSetForName;  ///< Node sets loaded.
	map<string, VuoCompilerModule *> libraryModules;  ///< Library modules loaded.
	VuoCompilerModule * inMemoryModuleAwaitingLoad;  ///< The in-memory module that the compiler has been requested to load and this environment will need to handle when the compiler is ready, or null if none.
	map<string, dispatch_group_t> specializedModulesLoading;  ///< Module keys of possibly specialized-generic modules that are in the process of being checked if they are specialized and, if so, generated and loaded.
	map<string, map<string, VuoModuleInfo *> > moduleFilesAtSearchPath;  ///< The module files seen (but not necessarily loaded) from moduleSearchPaths.
	map<string, map<string, VuoModuleInfo *> > sourceFilesAtSearchPath;  ///< The source files seen (but not necessarily loaded) from moduleSearchPaths.
	vector<string> moduleSearchPaths;  ///< Search paths for node classes, types, and library modules.
	vector<string> headerSearchPaths;  ///< Search paths for header/include files.
	vector<string> librarySearchPaths;  ///< Search paths for libraries (other than Vuo library modules).
	vector<string> frameworkSearchPaths;  ///< Search paths for frameworks.
	vector<string> expatriateSourceFiles;  ///< Paths of source files belonging to this environment that are located elsewhere than a module search path.
	shared_ptr<VuoModuleCache> moduleCache;  ///< The module cache used (not exclusively) by this environment.
	string compiledModuleCachePath;  ///< The directory in the module cache containing compiled/generated bitcode. This path is generated once and saved to improve performance.
	string overriddenCompiledModuleCachePath;  ///< The directory in the module cache containing compiled/generated bitcode for unsaved edits to modules. This path is generated once and saved to improve performance.
	bool isModuleCacheableDataDirty;  ///< True if the module cache may be out-of-date due to changes in this environment.
	VuoModuleCacheManifest cacheableModulesAndDependencies;  ///< A list of the modules and static libraries from this environment that can be stored in the module cache.
	set<string> dylibsNeededToLinkToThisCache;  ///< The paths of the dylibs that the module cache dylib needs to link to for this environment.
	set<string> frameworksNeededToLinkToThisCache;  ///< The names of the frameworks that the module cache dylib needs to link to for this environment.
	VuoDirectedAcyclicGraph *dependencyGraph;  ///< A full dependency graph, containing all modules that have been loaded and their dependencies.
	VuoDirectedAcyclicGraph *compositionDependencyGraph;  ///< A partial dependency graph, containing all subcompositions (loaded or not) and the node classes that are their direct dependencies.
	VuoModuleCompilationQueue *moduleCompilationQueue;  ///< Ensures that successive versions of source files are compiled in the right order.

	void updateModulesAtSearchPath(const string &path);
	void updateModuleAtSearchPath(const string &moduleSearchPath, const string &moduleRelativePath);
	void updateSourceFilesAtSearchPath(const string &path);
	void unmangleModuleKeysAtSearchPath(const string &path, const set<string> &knownModuleKeys);
	void startWatchingModuleSearchPath(const string &moduleSearchPath);
	bool writeToCompiledModuleCache(Module *module, const string &compiledModulePath, shared_ptr<VuoMakeDependencies> makeDependencies, dispatch_queue_t llvmQueue, VuoCompilerIssues *issues);
	void deleteFromCompiledModuleCache(const string &compiledModulePath);
	VuoCompilerModule * readModuleFromFile(VuoModuleInfo *moduleInfo, dispatch_queue_t llvmQueue);
	void loadInMemoryModule(const string &moduleKey, const string &moduleSourceCode, Module *module, std::function<void(void)> moduleLoadedCallback, VuoCompiler *compiler, dispatch_queue_t llvmQueue);
	void loadInMemoryModule(VuoCompilerModule *module, const string &moduleSourceCode, std::function<void(void)> moduleLoadedCallback, VuoCompiler *compiler, dispatch_queue_t llvmQueue);

	friend class TestCompilingAndLinking;

public:
	dispatch_queue_t moduleSearchPathContentsChangedQueue;  ///< Synchronizes calls to `moduleSearchPathContentsChanged()`. It's OK to call `VuoCompiler::environmentQueue` from this queue.

	explicit VuoCompilerEnvironment(string target, bool builtIn, bool generated);
	virtual ~VuoCompilerEnvironment(void);
	string getTarget();
	void addCompilerToNotify(VuoCompiler *compiler);
	void removeCompilerToNotify(VuoCompiler *compiler);
	map<string, VuoCompilerNodeClass *> getNodeClasses(void);
	VuoCompilerNodeClass * getNodeClass(const string &moduleKey);
	map<string, VuoCompilerType *> getTypes(void);
	VuoCompilerType * getType(const string &moduleKey);
	map<string, VuoNodeSet *> getNodeSets();
	VuoCompilerModule *getLibraryModule(const string &libraryModuleName);
	map<string, VuoCompilerModule *> getLibraryModules(void);
	VuoCompilerModule * findModule(const string &moduleKey);
	VuoNodeSet * findNodeSet(const string &name);
	void addModuleSearchPath(const string &path, bool shouldWatch = true);
	vector<string> getModuleSearchPaths(void);
	void addHeaderSearchPath(const string &path);
	vector<string> getHeaderSearchPaths(void);
	void addLibrarySearchPath(const string &path);
	vector<string> getLibrarySearchPaths(void);
	void addFrameworkSearchPath(const string &path);
	void setModuleCache(shared_ptr<VuoModuleCache> moduleCache);
	shared_ptr<VuoModuleCache> getModuleCache(void);
	string getCompiledModuleCachePath(void);
	string getOverriddenCompiledModuleCachePath(void);
	vector<string> getFrameworkSearchPaths(void);
	VuoDirectedAcyclicGraph * getDependencyGraph(void);
	VuoDirectedAcyclicGraph * getCompositionDependencyGraph(void);
	void addExpatriateSourceFile(const string &sourcePath);
	void removeExpatriateSourceFile(const string &sourcePath);
	VuoModuleInfo * listModule(const string &moduleKey);
	VuoModuleInfoIterator listModules(const set<string> &moduleKeys);
	VuoModuleInfoIterator listAllModules(void);
	VuoModuleInfo * listSourceFile(const string &moduleKey);
	VuoModuleInfoIterator listSourceFiles(const set<string> &moduleKeys);
	VuoModuleInfoIterator listAllSourceFiles(void);
	static vector<string> getBuiltInModuleSearchPaths(void);
	static vector<string> getBuiltInLibrarySearchPaths(void);
	static vector<string> getBuiltInFrameworkSearchPaths(void);
	void stopWatchingModuleSearchPaths(void);
	void fileChanged(const string &moduleSearchPath);
	void moduleSearchPathContentsChanged(const string &moduleSearchPath);
	void moduleFileChanged(const string &moduleKey, const string &modulePath, const string &moduleSourceCode, std::function<void(void)> moduleLoadedCallback, VuoCompiler *compiler, VuoCompilerIssues *issues = nullptr);
	void deleteOverriddenModuleFile(const string &moduleKey);
	void notifyCompilers(const set<VuoCompilerModule *> &modulesAdded, const set<pair<VuoCompilerModule *, VuoCompilerModule *> > &modulesModified, const set<VuoCompilerModule *> &modulesRemoved, VuoCompilerIssues *issues, bool oldModulesInvalidated = true);
	set<VuoCompilerModule *> loadCompiledModules(const set<string> &moduleKeys, const map<string, string> &sourceCodeForModule, dispatch_queue_t llvmQueue);
	set<dispatch_group_t> generateSpecializedModules(const set<string> &moduleKeys, VuoCompiler *compiler, dispatch_group_t moduleSourceCompilersExist, dispatch_queue_t llvmQueue);
	set<dispatch_group_t> compileModulesFromSourceCode(const set<string> &moduleKeys, bool shouldRecompileIfUnchanged, dispatch_group_t moduleSourceCompilersExist, dispatch_queue_t llvmQueue);
	set<VuoCompilerModule *> unloadCompiledModules(const set<string> &moduleKeys);
	void deleteFromCompiledModuleCache(const set<string> &moduleKeys);
	void addToDependencyGraph(VuoCompilerModule *module);
	void removeFromDependencyGraph(VuoCompilerModule *module);
	VuoModuleCacheManifest getCacheableModulesAndDependencies(set<string> &dylibsNeededToLinkToThisCache, set<string> &frameworksNeededToLinkToThisCache);
	void modulesChanged(void);

	bool isBuiltInOriginal(void);
	bool isBuiltIn(void);
	bool isGenerated(void);
	string getName();

#ifdef VUO_PRO
#include "../compiler/pro/VuoCompilerEnvironment_Pro.hh"
#endif
};

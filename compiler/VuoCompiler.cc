/**
 * @file
 * VuoCompiler implementation.
 *
 * @copyright Copyright © 2012–2014 Kosada Incorporated.
 * This code may be modified and distributed under the terms of the GNU Lesser General Public License (LGPL) version 2 or later.
 * For more information, see http://vuo.org/license.
 */

#include <fcntl.h>
#include <string.h>
#include <sstream>
#include "VuoCompiler.hh"
#include "VuoCompilerBitcodeGenerator.hh"
#include "VuoCompilerCodeGenUtilities.hh"
#include "VuoCompilerException.hh"
#include "VuoCompilerGenericType.hh"
#include "VuoCompilerMakeListNodeClass.hh"
#include "VuoCompilerNodeClass.hh"
#include "VuoCompilerSpecializedNodeClass.hh"
#include "VuoNodeSet.hh"
#include "VuoPort.hh"
#include "VuoStringUtilities.hh"

#ifdef PREMIUM_NODE_LOADER_ENABLED
#include "VuoPremiumNodeLoader.hh"
#endif

bool VuoCompiler::isLlvmInitialized = false;
dispatch_queue_t VuoCompiler::llvmQueue = dispatch_queue_create("org.vuo.compiler.llvm", NULL);
dispatch_queue_t VuoCompiler::environmentQueue = dispatch_queue_create("org.vuo.compiler.environment", NULL);
dispatch_queue_t VuoCompiler::cachedResourcesQueue = dispatch_queue_create("org.vuo.compiler.cache", NULL);
bool VuoCompiler::hasTriedCachedResources = false;
string VuoCompiler::cachedResourceDylib;
set<string> VuoCompiler::cachedResources;
set<string> VuoCompiler::encounteredPremiumModules;
VuoCompiler::Environment * VuoCompiler::sharedEnvironment = NULL;

/**
 * Creates an empty environment.
 */
VuoCompiler::Environment::Environment(bool isOwner)
{
	this->isOwner = isOwner;
}

/**
 * Destructor.
 */
VuoCompiler::Environment::~Environment(void)
{
	if (! isOwner)
		return;

	set<Module *> modulesToDelete;

	for (map<string, VuoCompilerNodeClass *>::iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoNodeClass *base = i->second->getBase();
		delete i->second;
		delete base;
	}
	for (map<string, VuoCompilerType *>::iterator i = types.begin(); i != types.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoType *base = i->second->getBase();
		delete i->second;
		delete base;
	}
	for (set<VuoCompilerGenericType *>::iterator i = genericTypes.begin(); i != genericTypes.end(); ++i)
	{
		VuoType *base = (*i)->getBase();
		delete *i;
		delete base;
	}
	for (map<string, VuoCompilerModule *>::iterator i = libraryModules.begin(); i != libraryModules.end(); ++i)
	{
		modulesToDelete.insert( i->second->getModule() );
		VuoModule *base = i->second->getPseudoBase();
		delete i->second;
		delete base;
	}

	for (set<Module *>::iterator i = modulesToDelete.begin(); i != modulesToDelete.end(); ++i)
		deleteModule(*i);

	for (map<string, VuoNodeSet *>::iterator i = nodeSetForName.begin(); i != nodeSetForName.end(); ++i)
		delete i->second;
}

/**
 * Returns the node classes loaded, plus specialized node classes generated by the compiler.
 */
map<string, VuoCompilerNodeClass *> VuoCompiler::Environment::getNodeClasses(void)
{
	__block map<string, VuoCompilerNodeClass *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = nodeClasses;
				  });
	return ret;
}

/**
 * Returns the types loaded.
 */
map<string, VuoCompilerType *> VuoCompiler::Environment::getTypes(void)
{
	__block map<string, VuoCompilerType *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = types;
				  });
	return ret;
}

/**
 * Returns the library modules loaded.
 */
map<string, VuoCompilerModule *> VuoCompiler::Environment::getLibraryModules(void)
{
	__block map<string, VuoCompilerModule *> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = libraryModules;
				  });
	return ret;
}

/**
 * Returns the node set with the given name, or null no such node set been loaded.
 */
VuoNodeSet * VuoCompiler::Environment::findNodeSet(const string &name)
{
	__block VuoNodeSet *nodeSet = NULL;

	dispatch_sync(environmentQueue, ^{
					  map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(name);
					  if (nodeSetIter != nodeSetForName.end())
					  {
						  nodeSet = nodeSetIter->second;
					  }
				  });

	return nodeSet;
}

/**
 * Adds a search path for node classes, types, and library modules.
 */
void VuoCompiler::Environment::addModuleSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  moduleSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for node classes, types, and library modules.
 */
vector<string> VuoCompiler::Environment::getModuleSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = moduleSearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for header/include files.
 */
void VuoCompiler::Environment::addHeaderSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  headerSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for header/include files.
 */
vector<string> VuoCompiler::Environment::getHeaderSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = headerSearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for libraries (other than Vuo library modules).
 */
void VuoCompiler::Environment::addLibrarySearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  librarySearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for libraries (other than Vuo library modules).
 */
vector<string> VuoCompiler::Environment::getLibrarySearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = librarySearchPaths;
				  });
	return ret;
}

/**
 * Adds a search path for frameworks.
 */
void VuoCompiler::Environment::addFrameworkSearchPath(const string &path)
{
	dispatch_sync(environmentQueue, ^{
					  frameworkSearchPaths.push_back(path);
				  });
}

/**
 * Returns the search paths for frameworks.
 */
vector<string> VuoCompiler::Environment::getFrameworkSearchPaths(void)
{
	__block vector<string> ret;
	dispatch_sync(environmentQueue, ^{
					  ret = frameworkSearchPaths;
				  });
	return ret;
}

/**
 * Loads node classes and types from any directories in moduleSearchPaths that have not already been loaded.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::loadModulesIntoCombinedEnvironment(Environment *myEnvironment, Environment *sharedEnvironment)
{
	dispatch_sync(environmentQueue, ^{
					  bool wereModulesLoaded = false;
					  Environment *envs[2] = { sharedEnvironment, myEnvironment };

					  for (int i = 0; i < 2; ++i)
					  {
						  for (vector<string>::iterator j = envs[i]->moduleSearchPaths.begin(); j != envs[i]->moduleSearchPaths.end(); ++j)
						  {
							  string path = *j;
							  if (! envs[i]->isModuleSearchPathLoaded[path])
							  {
								  envs[i]->loadModules(path);
								  envs[i]->isModuleSearchPathLoaded[path] = true;
								  wereModulesLoaded = true;
							  }
						  }
					  }

					  if (wereModulesLoaded)
					  {
						  sharedEnvironment->reifyPortTypes(NULL);
						  myEnvironment->reifyPortTypes(sharedEnvironment);
						  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
					  }
				  });
}

/**
 * Adds a node class to use when linking a composition.
 *
 * Typically, node classes are loaded from file with addModuleSearchPath().
 * This function is useful if adding a node class that is generated at compile time.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 */
void VuoCompiler::Environment::addNodeClassToCombinedEnvironment(VuoCompilerNodeClass *nodeClass,
																 Environment *myEnvironment, Environment *sharedEnvironment)
{
	dispatch_sync(environmentQueue, ^{
					  dispatch_sync(llvmQueue, ^{
						  setTargetForModule(nodeClass->getModule());
					  });

					  myEnvironment->nodeClasses[nodeClass->getBase()->getModuleKey()] = nodeClass;

					  myEnvironment->reifyPortTypes(sharedEnvironment);
					  updateCombinedEnvironment(myEnvironment, sharedEnvironment);
				  });
}

/**
 * Loads all node classes, types, and library modules in the directory at @c path.
 * Adds @c path to the list of library search paths used in linking.
 *
 * The top level of the directory is searched for .vuonode and .bc files.
 * A .vuonode file may be either a module or an archive containing modules.
 * In the latter case, the .vuonode archive's top level is searched.
 *
 * If multiple definitions of a node class or type are encountered (either in different folders
 * inside of @c path or in different calls to this function), the most recently encountered
 * definition is used.
 *
 * If @c path does not exist, does nothing.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::loadModules(string path)
{
	const string premiumNodeExtension = "vuonode+";
	const string premiumNodeLibraryExtension = "bc+";
	/// @todo Search recursively - https://b33p.net/kosada/node/2468

	set<string> moduleExtensions;
	moduleExtensions.insert("bc");
	moduleExtensions.insert("vuonode");
	moduleExtensions.insert(premiumNodeExtension);
	moduleExtensions.insert(premiumNodeLibraryExtension);
	set<string> archiveExtensions;
	archiveExtensions.insert("vuonode");
	set<VuoFileUtilities::File *> moduleFiles = VuoFileUtilities::findFilesInDirectory(path, moduleExtensions, archiveExtensions);
	for (set<VuoFileUtilities::File *>::iterator i = moduleFiles.begin(); i != moduleFiles.end(); ++i)
	{
		bool moduleParseError = false;
		bool premiumModule = false;
		VuoFileUtilities::File *moduleFile = *i;
		string moduleKey, dir, ext;
		VuoFileUtilities::splitPath(moduleFile->getRelativePath(), dir, moduleKey, ext);

		size_t inputDataBytes;
		char *rawInputData = moduleFile->getContentsAsRawData(inputDataBytes);
		char *processedInputData = NULL;

		if ((ext == premiumNodeExtension) || (ext == premiumNodeLibraryExtension))
		{
			encounteredPremiumModules.insert(moduleKey);

#ifdef PREMIUM_NODE_LOADER_ENABLED
			if (inputDataBytes <= INT_MAX)
				processedInputData = VuoPremiumNodeLoader::getPremiumDataContent(rawInputData,
																				 static_cast<int>(inputDataBytes),
																				 moduleKey.c_str());
#endif

			if (!processedInputData)
			{
				moduleParseError = true;
				//VLog("Error: Couldn't extract premium content from file '%s'.", moduleFile->getRelativePath().c_str());
			}

			free(rawInputData);
			premiumModule = true;
		}
		else
			processedInputData = rawInputData;

		Module *module = NULL;
		if (!moduleParseError)
		{
			string moduleReadError;
			module = readModuleFromBitcodeData(processedInputData, inputDataBytes, moduleReadError);
			free(processedInputData);

			if (!module)
			{
				moduleParseError = true;
				VLog("Error: Couldn't parse module '%s': %s.", moduleFile->getRelativePath().c_str(), moduleReadError.c_str());
			}
		}

		if (!moduleParseError)
		{
			__block VuoCompilerModule *compilerModule;
			dispatch_sync(llvmQueue, ^{
							  compilerModule = VuoCompilerModule::newModule(moduleKey, module);
						  });

			if (compilerModule)
			{
				if (dynamic_cast<VuoCompilerNodeClass *>(compilerModule))
					nodeClasses[moduleKey] = static_cast<VuoCompilerNodeClass *>(compilerModule);
				else if (dynamic_cast<VuoCompilerType *>(compilerModule))
					types[moduleKey] = static_cast<VuoCompilerType *>(compilerModule);
				else
					libraryModules[moduleKey] = compilerModule;

				VuoNodeSet *nodeSet = VuoNodeSet::createNodeSetForModule(moduleFile);
				if (nodeSet)
				{
					map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(nodeSet->getName());
					if (nodeSetIter == nodeSetForName.end())
					{
						nodeSetForName[nodeSet->getName()] = nodeSet;
					}
					else
					{
						delete nodeSet;
						nodeSet = nodeSetIter->second;
					}
					compilerModule->getPseudoBase()->setNodeSet(nodeSet);
				}

				compilerModule->setPremium(premiumModule);
			}
			else
			{
				deleteModule(module);
			}
		}

		delete moduleFile;
	}
}

/**
 * Updates the data-and-event ports of each known node class to match them up with known types.
 * This method needs to be called between when the last node class or type is loaded and
 * when a composition is compiled. It can be called multiple times.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::reifyPortTypes(Environment *outerEnvironment)
{
	map<string, VuoCompilerNodeClass *> searchNodeClasses;
	map<string, VuoCompilerType *> searchTypes;

	if (outerEnvironment)
		searchNodeClasses.insert(outerEnvironment->nodeClasses.begin(), outerEnvironment->nodeClasses.end());
	searchNodeClasses.insert(nodeClasses.begin(), nodeClasses.end());

	if (outerEnvironment)
		searchTypes.insert(outerEnvironment->types.begin(), outerEnvironment->types.end());
	searchTypes.insert(types.begin(), types.end());

	for (map<string, VuoCompilerNodeClass *>::iterator i = searchNodeClasses.begin(); i != searchNodeClasses.end(); ++i)
	{
		VuoNodeClass *nodeClass = i->second->getBase();

		vector<VuoPortClass *> inputPortClasses = nodeClass->getInputPortClasses();
		vector<VuoPortClass *> outputPortClasses = nodeClass->getOutputPortClasses();
		vector<VuoPortClass *> portClasses;
		portClasses.insert(portClasses.end(), inputPortClasses.begin(), inputPortClasses.end());
		portClasses.insert(portClasses.end(), outputPortClasses.begin(), outputPortClasses.end());

		for (vector<VuoPortClass *>::iterator j = portClasses.begin(); j != portClasses.end(); ++j)
		{
			VuoCompilerPortClass *portClass = static_cast<VuoCompilerPortClass *>((*j)->getCompiler());
			VuoType *baseType = portClass->getDataVuoType();

			if (baseType && ! baseType->hasCompiler())
			{
				string typeName = baseType->getModuleKey();
				__block VuoCompilerType *reifiedType = NULL;

				VuoGenericType *genericType = dynamic_cast<VuoGenericType *>(baseType);
				if (genericType)
				{
					dispatch_sync(llvmQueue, ^{
									  reifiedType = VuoCompilerGenericType::newGenericType(genericType, searchTypes);
								  });
					if (reifiedType)
						genericTypes.insert( static_cast<VuoCompilerGenericType *>(reifiedType) );
				}
				else
				{
					map<string, VuoCompilerType *>::iterator reifiedTypeIter = searchTypes.find(typeName);
					if (reifiedTypeIter != searchTypes.end())
					{
						delete baseType;
						reifiedType = reifiedTypeIter->second;
					}
				}

				if (reifiedType)
					portClass->setDataVuoType(reifiedType->getBase());
			}
		}
	}
}

/**
 * Updates this environment to consist of @a myEnvironment layered on top of @a sharedEnvironment.
 *
 * This function should be called on VuoCompiler::combinedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::updateCombinedEnvironment(Environment *myEnvironment, Environment *sharedEnvironment)
{
	nodeClasses.clear();
	types.clear();
	genericTypes.clear();
	nodeSetForName.clear();
	libraryModules.clear();
	isModuleSearchPathLoaded.clear();
	moduleSearchPaths.clear();
	headerSearchPaths.clear();
	librarySearchPaths.clear();
	frameworkSearchPaths.clear();

	Environment *envs[2] = { sharedEnvironment, myEnvironment };
	for (int i = 0; i < 2; ++i)
	{
		nodeClasses.insert(envs[i]->nodeClasses.begin(), envs[i]->nodeClasses.end());
		types.insert(envs[i]->types.begin(), envs[i]->types.end());
		genericTypes.insert(envs[i]->genericTypes.begin(), envs[i]->genericTypes.end());
		nodeSetForName.insert(envs[i]->nodeSetForName.begin(), envs[i]->nodeSetForName.end());
		libraryModules.insert(envs[i]->libraryModules.begin(), envs[i]->libraryModules.end());
		isModuleSearchPathLoaded.insert(envs[i]->isModuleSearchPathLoaded.begin(), envs[i]->isModuleSearchPathLoaded.end());
		moduleSearchPaths.insert(moduleSearchPaths.end(), envs[i]->moduleSearchPaths.begin(), envs[i]->moduleSearchPaths.end());
		headerSearchPaths.insert(headerSearchPaths.end(), envs[i]->headerSearchPaths.begin(), envs[i]->headerSearchPaths.end());
		librarySearchPaths.insert(librarySearchPaths.end(), envs[i]->librarySearchPaths.begin(), envs[i]->librarySearchPaths.end());
		frameworkSearchPaths.insert(frameworkSearchPaths.end(), envs[i]->frameworkSearchPaths.begin(), envs[i]->frameworkSearchPaths.end());
	}
}

/**
 * Adds the search paths needed by all compositions to this environment.
 *
 * This function should be called on VuoCompiler::sharedEnvironment.
 *
 * @threadQueue{environmentQueue}
 */
void VuoCompiler::Environment::addSearchPathsToSharedEnvironment(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		frameworkSearchPaths.push_back(vuoFrameworkPath + "/Modules/");

		moduleSearchPaths.push_back(vuoFrameworkPath + "/Modules/");
		librarySearchPaths.push_back(vuoFrameworkPath + "/Modules/");

		frameworkSearchPaths.push_back(vuoFrameworkPath + "/Frameworks/");

		headerSearchPaths.push_back(vuoFrameworkPath + "/Headers/");
		headerSearchPaths.push_back(vuoFrameworkPath + "/Headers/macos");  // system headers installed by Xcode Command Line Tools
	}
	else
	{
		moduleSearchPaths.push_back(VUO_ROOT "/library");
		moduleSearchPaths.push_back(VUO_ROOT "/node");
		moduleSearchPaths.push_back(VUO_ROOT "/type");
		moduleSearchPaths.push_back(VUO_ROOT "/type/list");
		librarySearchPaths.push_back(VUO_ROOT "/library");
		librarySearchPaths.push_back(VUO_ROOT "/node");
		librarySearchPaths.push_back(VUO_ROOT "/type");
		librarySearchPaths.push_back(VUO_ROOT "/type/list");
		librarySearchPaths.push_back(VUO_ROOT "/runtime");

		librarySearchPaths.push_back(GRAPHVIZ_ROOT "/lib/");
		librarySearchPaths.push_back(GRAPHVIZ_ROOT "/lib/graphviz/");
		librarySearchPaths.push_back(JSONC_ROOT "/lib/");
		librarySearchPaths.push_back(ZMQ_ROOT "/lib/");
		librarySearchPaths.push_back(LEAP_ROOT);
		librarySearchPaths.push_back(MUPARSER_ROOT "/lib/");
		librarySearchPaths.push_back(FREEIMAGE_ROOT "/lib/");
		librarySearchPaths.push_back(CURL_ROOT "/lib/");
		librarySearchPaths.push_back(RTMIDI_ROOT "/lib/");
		librarySearchPaths.push_back(RTAUDIO_ROOT "/lib/");
		librarySearchPaths.push_back(GAMMA_ROOT "/lib/");
		librarySearchPaths.push_back(ASSIMP_ROOT "/lib/");
		librarySearchPaths.push_back(FFMPEG_ROOT "/lib/");
		librarySearchPaths.push_back(LIBUSB_ROOT "/lib/");
		librarySearchPaths.push_back(LIBFREENECT_ROOT "/lib/");
		frameworkSearchPaths.push_back(SYPHON_ROOT);
		librarySearchPaths.push_back(OSCPACK_ROOT "/lib/");
		librarySearchPaths.push_back(ZXING_ROOT "/lib/");
		librarySearchPaths.push_back(LIBXML2_ROOT "/lib/");
		librarySearchPaths.push_back(VUO_ROOT "/runtime");

		headerSearchPaths.push_back(VUO_ROOT "/library");
		headerSearchPaths.push_back(VUO_ROOT "/node");
		headerSearchPaths.push_back(VUO_ROOT "/node/vuo.font");
		headerSearchPaths.push_back(VUO_ROOT "/type");
		headerSearchPaths.push_back(VUO_ROOT "/type/list");
		headerSearchPaths.push_back(VUO_ROOT "/runtime");
	}

	// Allow system administrator to override Vuo.framework modules
	moduleSearchPaths.push_back(VuoFileUtilities::getSystemModulesPath());
	librarySearchPaths.push_back(VuoFileUtilities::getSystemModulesPath());

	// Allow user to override Vuo.framework and system-wide modules
	moduleSearchPaths.push_back(VuoFileUtilities::getUserModulesPath());
	librarySearchPaths.push_back(VuoFileUtilities::getUserModulesPath());
}

/**
 * Creates a compiler instance that can be used for compiling and linking.
 */
VuoCompiler::VuoCompiler(void)
	: myEnvironment(true), combinedEnvironment(false)
{
	dispatch_sync(llvmQueue, ^{
					  if (! isLlvmInitialized)
					  {
						  isLlvmInitialized = true;

						  llvm::InitializeNativeTarget();

						  // If the Vuo compiler/linker...
						  //   1. Loads a node class that uses dispatch_object_t.
						  //   2. Generates code that uses dispatch_object_t.
						  //   3. Links the node class into a composition.
						  //   4. Generates more code that uses dispatch_object_t.
						  // ... then Step 4 ends up with the wrong llvm::Type for dispatch_object_t.
						  //
						  // A workaround is to generate some code that uses dispatch_object_t before doing Step 1.
						  //
						  // https://b33p.net/kosada/node/3845
						  // http://lists.cs.uiuc.edu/pipermail/llvmdev/2012-December/057075.html
						  Module module("", getGlobalContext());
						  VuoCompilerCodeGenUtilities::getDispatchObjectType(&module);
					  }
				  });

	isVerbose = false;

	Environment *env = getSharedEnvironment();
	dispatch_sync(environmentQueue, ^{
					  combinedEnvironment.updateCombinedEnvironment( &myEnvironment, env );
				  });

	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
		clangPath = vuoFrameworkPath + "/Frameworks/llvm.framework/Versions/A/Helpers/clang";
	else
		clangPath = llvm::sys::Path(StringRef(LLVM_ROOT "/bin/clang"));
}

/**
 * Destructor.
 */
VuoCompiler::~VuoCompiler(void)
{
	dispatch_sync(cachedResourcesQueue, ^{});  // Wait for any asynchronous calls on this queue to complete.
}

/**
 * Returns the singleton shared by all VuoCompiler instances.
 */
VuoCompiler::Environment * VuoCompiler::getSharedEnvironment(void)
{
	dispatch_sync(environmentQueue, ^{
					  if (! sharedEnvironment)
					  {
						  sharedEnvironment = new Environment(true);
						  sharedEnvironment->addSearchPathsToSharedEnvironment();
					  }
				  });

	return sharedEnvironment;
}

/**
 * Loads node classes and types from any directories in the module search paths that have not already been loaded.
 *
 * In this class, the modules for node classes, types, and library modules are loaded lazily.
 * They are loaded the first time they are accessed (by strategically placed calls to this function).
 * Specifically, they are loaded the first time compiling a composition, linking a composition, or otherwise
 * accessing the collections of node classes or types. They are not loaded when compiling a node class.
 */
void VuoCompiler::loadModulesIfNeeded(void)
{
	combinedEnvironment.loadModulesIntoCombinedEnvironment( &myEnvironment, getSharedEnvironment() );
}

/**
 * Initializes the premium node loader with the license information provided.
 *
 * This function should be called before attempting to load any premium moduless.
 */
void VuoCompiler::setLicense(string licenseContent, string licenseSignature)
{
	#ifdef PREMIUM_NODE_LOADER_ENABLED
	VuoPremiumNodeLoader::initializeWithLicense(licenseContent, licenseSignature);
	#endif
}

/**
 * Updates the nodes and ports of the composition to have the correct backing types for generic types.
 *
 * Generic nodes in the composition may be replaced by equivalent nodes (keeping their node class name,
 * node title, and other metadata, but using a node class that has a different LLVM module).
 */
void VuoCompiler::reifyGenericPortTypes(VuoCompilerComposition *composition)
{
	set<VuoNode *> nodes = composition->getBase()->getNodes();

	// Set a backing type for each generic type that doesn't already have one.
	for (set<VuoNode *>::iterator i = nodes.begin(); i != nodes.end(); ++i)
	{
		VuoNode *node = *i;

		vector<VuoPort *> inputPorts = node->getInputPorts();
		vector<VuoPort *> outputPorts = node->getOutputPorts();
		vector<VuoPort *> ports;
		ports.insert(ports.end(), inputPorts.begin(), inputPorts.end());
		ports.insert(ports.end(), outputPorts.begin(), outputPorts.end());

		for (vector<VuoPort *>::iterator j = ports.begin(); j != ports.end(); ++j)
		{
			VuoCompilerPort *port = static_cast<VuoCompilerPort *>((*j)->getCompiler());
			VuoGenericType *genericType = dynamic_cast<VuoGenericType *>(port->getDataVuoType());
			if (! genericType)
				continue;

			if (! genericType->hasCompiler())
			{
				__block VuoCompilerGenericType *reifiedType;
				dispatch_sync(llvmQueue, ^{
								  reifiedType = VuoCompilerGenericType::newGenericType(genericType, this);
							  });
				if (reifiedType)
					port->setDataVuoType(reifiedType->getBase());
			}
		}
	}

	// For any node that needs a different backing type than its node class was compiled with,
	// recompile the node class with the desired backing type, instantiate a replacement node
	// from the new node class, and substitute the replacement node into the composition.
	for (set<VuoNode *>::iterator i = nodes.begin(); i != nodes.end(); ++i)
	{
		VuoNode *node = *i;

		VuoCompilerSpecializedNodeClass *nodeClass = dynamic_cast<VuoCompilerSpecializedNodeClass *>(node->getNodeClass()->getCompiler());
		if (! nodeClass)
			continue;

		bool doBackingTypesMatch = true;
		map<string, string> backingTypesForNodeClass = VuoCompilerSpecializedNodeClass::getBackingTypeNamesFromPorts(node->getNodeClass());
		map<string, string> backingTypesForNode = VuoCompilerSpecializedNodeClass::getBackingTypeNamesFromPorts(node);
		for (map<string, string>::iterator j = backingTypesForNode.begin(); j != backingTypesForNode.end(); ++j)
		{
			string genericType = j->first;
			string backingTypeForNode = j->second;

			if (backingTypesForNodeClass[genericType] != backingTypeForNode)
				doBackingTypesMatch = false;
		}

		if (! doBackingTypesMatch)
		{
			VuoNodeClass *replacementNodeClass =
					(dynamic_cast<VuoCompilerMakeListNodeClass *>(nodeClass) ?
						 VuoCompilerMakeListNodeClass::newNodeClass(nodeClass->getBase()->getClassName(), this, llvmQueue, node) :
						 VuoCompilerSpecializedNodeClass::newNodeClass(nodeClass->getBase()->getClassName(), this, llvmQueue, node));
			VuoNode *replacementNode = replacementNodeClass->getCompiler()->newNode(node);
			replacementNode->getCompiler()->setGraphvizIdentifier( node->getCompiler()->getGraphvizIdentifier() );
			composition->getBase()->replaceNode(node, replacementNode);
		}
	}
}

/**
 * Compiles a node class, port type, or library module to LLVM bitcode.
 *
 * @param inputPath The file to compile, containing a C implementation of the node class, port type, or library module.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 */
void VuoCompiler::compileModule(string inputPath, string outputPath)
{
	compileModule(inputPath, outputPath, vector<string>());
}

/**
 * Compiles a node class, port type, or library module to LLVM bitcode.
 *
 * @param inputPath The file to compile, containing a C implementation of the node class, port type, or library module.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @param includePaths Directories with header files to be included when compiling.
 */
void VuoCompiler::compileModule(string inputPath, string outputPath, const vector<string> &includePaths)
{
	if (isVerbose)
		print();

	vector<string> allIncludePaths = includePaths;
	string preprocessedInputPath = inputPath;

	string tmpPreprocessedInputDir;
	string dir, file, ext;
	VuoFileUtilities::splitPath(inputPath, dir, file, ext);
	if (ext == "c")
	{
		string inputContents = VuoFileUtilities::readFileToString(inputPath);
		string preprocessedInputContents = inputContents;
		VuoCompilerSpecializedNodeClass::replaceGenericTypesWithBacking(preprocessedInputContents);
		if (inputContents != preprocessedInputContents)
		{
			// Unspecialized generic node class
			allIncludePaths.push_back(dir.empty() ? "." : dir);
			tmpPreprocessedInputDir = VuoFileUtilities::makeTmpDir(file);
			preprocessedInputPath = tmpPreprocessedInputDir + "/" + file + "." + ext;
			VuoFileUtilities::preserveOriginalFileName(preprocessedInputContents, file + "." + ext);
			VuoFileUtilities::writeStringToFile(preprocessedInputContents, preprocessedInputPath);
		}
	}

	vector<string> extraArgs;
	for (vector<string>::iterator i = allIncludePaths.begin(); i != allIncludePaths.end(); ++i)
	{
		extraArgs.push_back("-I");
		extraArgs.push_back(*i);
	}

	Module *module = readModuleFromC(preprocessedInputPath, extraArgs);
	if (! tmpPreprocessedInputDir.empty())
		remove(tmpPreprocessedInputDir.c_str());
	if (! module)
	{
		VLog("Error: Couldn't compile '%s' to LLVM bitcode.", inputPath.c_str());
		return;
	}

	string moduleKey = getModuleNameForPath(inputPath);
	dispatch_sync(llvmQueue, ^{
					  VuoCompilerModule *compilerModule = VuoCompilerModule::newModule(moduleKey, module);
					  if (! compilerModule)
					  {
						  VLog("Error: Didn't recognize '%s' as a node class, type, or library.", inputPath.c_str());
						  return;
					  }

					  setTargetForModule(module, target);
					  writeModuleToBitcode(module, outputPath);

					  delete module;
				  });
}

/**
 * Compiles a composition to LLVM bitcode.
 *
 * If the composition contains generic nodes, then it may be modified to allow these generic nodes to be compiled.
 * See reifyGenericPortTypes() for more information.
 *
 * @param composition The composition to compile.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @throw std::exception The composition is invalid.
 */
void VuoCompiler::compileComposition(VuoCompilerComposition *composition, string outputPath)
{
	composition->check();

	reifyGenericPortTypes(composition);

	VuoCompilerBitcodeGenerator *generator = VuoCompilerBitcodeGenerator::newBitcodeGeneratorFromComposition(composition, this);
	if (telemetry == "console")
		generator->setDebugMode(true);

	dispatch_sync(llvmQueue, ^{
					  Module *module = generator->generateBitcode();
					  setTargetForModule(module, target);
					  writeModuleToBitcode(module, outputPath);
				  });

	delete generator;
}

/**
 * Compiles a composition, read from file, to LLVM bitcode.
 *
 * @param inputPath The .vuo file containing the composition.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @throw std::exception The composition is invalid.
 */
void VuoCompiler::compileComposition(string inputPath, string outputPath)
{
	if (isVerbose)
		print();

	string compositionString = VuoFileUtilities::readFileToString(inputPath);
	return compileCompositionString(compositionString, outputPath);
}

/**
 * Compiles the composition, read from a string, to LLVM bitcode.
 *
 * @param compositionString A string containing the composition.
 * @param outputPath The file in which to save the compiled LLVM bitcode.
 * @throw std::exception The composition is invalid.
 */
void VuoCompiler::compileCompositionString(const string &compositionString, string outputPath)
{
	VuoCompilerComposition *composition = VuoCompilerComposition::newCompositionFromGraphvizDeclaration(compositionString, this);
	compileComposition(composition, outputPath);

	VuoComposition *baseComposition = composition->getBase();
	delete composition;
	delete baseComposition;
}

/**
 * Turns a compiled composition into an executable by
 * linking in all of its dependencies and adding a main function.
 *
 * @param inputPath Path to the compiled composition (an LLVM bitcode file).
 * @param outputPath Path where the resulting executable should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting executable.
 * @param isApp If true, the resulting executable can be added to an app bundle.
 *			If false, the resulting executable will be headless unless the composition contains a window.
 * @param rPath An optional @c -rpath argument to be passed to clang.
 * @throw std::runtime_error At least one of the dependencies is incompatible with the targets for building the composition.
 */
void VuoCompiler::linkCompositionToCreateExecutable(string inputPath, string outputPath, Optimization optimization,
													bool isApp, string rPath)
{
	linkCompositionToCreateExecutableOrDynamicLibrary(inputPath, outputPath, optimization, false, isApp, rPath);
}

/**
 * Turns a compiled composition into a dynamic library by
 * linking in all of its dependencies.
 *
 * @param inputPath Path to the compiled composition (an LLVM bitcode file).
 * @param outputPath Path where the resulting dynamic library should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting dynamic library.
 * @throw std::runtime_error At least one of the dependencies is incompatible with the targets for building the composition.
 */
void VuoCompiler::linkCompositionToCreateDynamicLibrary(string inputPath, string outputPath, Optimization optimization)
{
	linkCompositionToCreateExecutableOrDynamicLibrary(inputPath, outputPath, optimization, true);
}

/**
 * Creates an executable or dynamic library that contains the composition and its dependencies.
 *
 * If creating an executable, a main function is added.
 *
 * @param compiledCompositionPath Path to the compiled composition (n LLVM bitcode file).
 * @param linkedCompositionPath Path where the resulting executable or dynamic library should be placed.
 * @param optimization Controls the time it takes to link the composition and the size and dependencies of the
 *			resulting executable or dynamic library.
 * @param isDylib True if creating a dynamic library, false if creating an executable.
 * @param isApp If true, the resulting executable can be added to an app bundle.
 *			If false, the resulting executable will be headless unless the composition contains a window.
 * @param rPath An optional @c -rpath argument to be passed to clang.
 * @throw std::runtime_error At least one of the dependencies is incompatible with the targets for building the composition.
 * @throw VuoCompilerException The linker encountered errors and failed.
 */
void VuoCompiler::linkCompositionToCreateExecutableOrDynamicLibrary(string compiledCompositionPath, string linkedCompositionPath,
																	Optimization optimization, bool isDylib, bool isApp, string rPath)
{
	if (isVerbose)
		print();

	set<string> dependencies = getDependenciesForComposition(compiledCompositionPath);
	dependencies.insert(getRuntimeDependency());
	if (! isDylib)
		dependencies.insert(getRuntimeMainDependency());
	if (isApp)
	{
		string applicationDependency = getApplicationDependency();
		set<string> incompatibleDependencies;
		getDependenciesRecursively(applicationDependency, dependencies, incompatibleDependencies);
	}
	set<Module *> modules;
	set<string> libraries;
	set<string> frameworks;
	getLinkerInputs(dependencies, optimization == Optimization_FastBuild, modules, libraries, frameworks);

	libraries.insert(compiledCompositionPath);

	link(linkedCompositionPath, modules, libraries, frameworks, isDylib, rPath);
}

/**
 * Creates one dynamic library for the composition by itself and, if needed, another dynamic library for the
 * node classes and other resources that are dependencies of the composition.
 *
 * @param compiledCompositionPath Path to the compiled composition (an LLVM bitcode file).
 * @param linkedCompositionPath Path where the resulting dynamic library for the composition should be placed.
 * @param newLinkedResourcePath Path where the resulting dynamic library for the composition's resources should be placed.
 *				The dynamic library is only created if this version of the composition requires resources that are not in
 *				@c alreadyLinkedResources. When this function returns, if the dynamic library was created, then this
 *				argument is the same as when it was passed in; otherwise, this argument is the empty string.
 * @param alreadyLinkedResourcePaths Paths where the resulting dynamic libraries for the composition's resources have
 *				been placed in previous calls to this function. When this function returns, if a dynamic library was
 *				created at @c newLinkedResourcePath, it will be the last element in this list.
 * @param alreadyLinkedResources Names of resources that have been linked into the composition in previous calls to this
 *				function. When this function returns, any new resources will have been added to this list.
 * @throw std::runtime_error At least one of the dependencies is incompatible with the targets for building the composition.
 * @throw VuoCompilerException The linker encountered errors and failed. The values of @a newLinkedResourcePath,
 *				@a alreadyLinkedResourcePaths, and @a alreadyLinkedResources are unchanged.
 */
void VuoCompiler::linkCompositionToCreateDynamicLibraries(string compiledCompositionPath, string linkedCompositionPath,
														  string &newLinkedResourcePath, vector<string> &alreadyLinkedResourcePaths,
														  set<string> &alreadyLinkedResources)
{
	if (isVerbose)
		print();

	// Wait to update the passed-by-reference arguments until the end of this function, in case an exception is thrown.
	string tmpNewLinkedResourcePath = newLinkedResourcePath;
	vector<string> tmpAlreadyLinkedResourcePaths = alreadyLinkedResourcePaths;
	set<string> tmpAlreadyLinkedResources = alreadyLinkedResources;

	// Get the dependencies used by the new resources and not the previous resources.
	set<string> newDependencies = getDependenciesForComposition(compiledCompositionPath);
	set<string> newDependenciesCopy = newDependencies;
	for (set<string>::iterator i = newDependenciesCopy.begin(); i != newDependenciesCopy.end(); ++i)
		if (tmpAlreadyLinkedResources.find(*i) != tmpAlreadyLinkedResources.end())
			newDependencies.erase(newDependencies.find(*i));

	// Get the dynamic libraries and frameworks used by the new and previous resources.
	set<string> dylibs;
	set<string> frameworks;
	{
		set<Module *> modules;
		set<string> libraries;

		tmpAlreadyLinkedResources.insert(newDependencies.begin(), newDependencies.end());

		getLinkerInputs(tmpAlreadyLinkedResources, true, modules, libraries, frameworks);

		for (set<string>::iterator i = libraries.begin(); i != libraries.end(); ++i)
			if (VuoStringUtilities::endsWith(*i, ".dylib"))
				dylibs.insert(*i);
	}

	// Link the new resource dylib, if needed.
	if (! newDependencies.empty())
	{
		set<Module *> modules;
		set<string> libraries;

		libraries.insert(tmpAlreadyLinkedResourcePaths.begin(), tmpAlreadyLinkedResourcePaths.end());
		libraries.insert(dylibs.begin(), dylibs.end());
		getLinkerInputs(newDependencies, true, modules, libraries, frameworks);

		link(tmpNewLinkedResourcePath, modules, libraries, frameworks, true);

		tmpAlreadyLinkedResourcePaths.push_back(tmpNewLinkedResourcePath);
	}
	else
	{
		tmpNewLinkedResourcePath = "";
	}

	// Get the Vuo runtime dependency.
	string vuoRuntimePath;
	{
		set<Module *> modules;
		set<string> libraries;
		set<string> frameworks;

		set<string> dependencies;
		dependencies.insert(getRuntimeDependency());
		getLinkerInputs(dependencies, true, modules, libraries, frameworks);
		vuoRuntimePath = *libraries.begin();
	}

	// Link the composition.
	{
		set<Module *> modules;
		set<string> libraries;

		libraries.insert(compiledCompositionPath);
		libraries.insert(vuoRuntimePath);
		libraries.insert(tmpAlreadyLinkedResourcePaths.begin(), tmpAlreadyLinkedResourcePaths.end());
		libraries.insert(dylibs.begin(), dylibs.end());
		link(linkedCompositionPath, modules, libraries, frameworks, true);
	}

	newLinkedResourcePath = tmpNewLinkedResourcePath;
	alreadyLinkedResourcePaths = tmpAlreadyLinkedResourcePaths;
	alreadyLinkedResources = tmpAlreadyLinkedResources;
}

/**
 * Returns the names of dependencies (node classes, types, libraries, and frameworks)
 * needed for linking the composition.
 *
 * This includes the composition's nodes, their dependencies, and the libraries needed
 * by every linked composition. It does not include the Vuo runtime or a main function.
 *
 * @throw VuoCompilerException At least one of the dependencies is incompatible with the targets for building the composition.
 */
set<string> VuoCompiler::getDependenciesForComposition(const string &compiledCompositionPath)
{
	loadModulesIfNeeded();

	set<string> dependencies;

	// Add the node classes in the top-level composition and their dependencies.
	__block vector<string> directDependencies;
	Module *compositionModule = readModuleFromBitcode(compiledCompositionPath);
	dispatch_sync(llvmQueue, ^{
					  VuoCompilerBitcodeParser parser(compositionModule);
					  directDependencies = parser.getStringsFromGlobalArray("moduleDependencies");
					  delete compositionModule;
				  });
	for (vector<string>::iterator i = directDependencies.begin(); i != directDependencies.end(); ++i)
	{
		string dependency = *i;
		set<string> dependenciesToAdd;
		set<string> incompatibleDependencies;
		getDependenciesRecursively(dependency, dependenciesToAdd, incompatibleDependencies);

		if (incompatibleDependencies.empty())
		{
			dependencies.insert(dependenciesToAdd.begin(), dependenciesToAdd.end());
		}
		else
		{
			VuoCompilerTargetSet compositionTargets;
			compositionTargets.restrictToCurrentOperatingSystemVersion();

			string dependencyTargetString;
			VuoCompilerModule *module = getModule(dependency);
			if (module)
			{
				VuoCompilerTargetSet dependencyTargets = module->getCompatibleTargets();
				for (set<string>::iterator i = incompatibleDependencies.begin(); i != incompatibleDependencies.end(); ++i)
				{
					VuoCompilerModule *subModule = getModule(*i);
					if (subModule)
					{
						VuoCompilerTargetSet subDependencyTargets = subModule->getCompatibleTargets();
						dependencyTargets.restrictToBeCompatibleWithAllOf(subDependencyTargets);
					}
				}
				dependencyTargetString = dependencyTargets.toString();
			}
			else
				dependencyTargetString = "(unknown operating systems)";

			string details = dependency + " is only compatible with " + dependencyTargetString +
							 ", but this composition needs to run on " + compositionTargets.toString() + ".";
			vector<VuoCompilerError> errors;
			VuoCompilerError error("Node incompatible with operating system", details, set<VuoNode *>(), set<VuoCable *>());
			errors.push_back(error);
			throw VuoCompilerException(errors);
		}
	}

	// Add the libraries needed by every linked composition.
	vector<string> coreDependencies = getCoreVuoDependencies();
	dependencies.insert(coreDependencies.begin(), coreDependencies.end());

	return dependencies;
}

/**
 * Adds @a dependency and the names of all of its dependencies to @a compatibleDependencies and @a incompatibleDependencies.
 *
 * @param dependency The current dependency being searched for its dependencies.
 * @param[out] compatibleDependencies The dependencies found so far by calls to this function that are compatible with
 *			the targets for building the composition.
 * @param[out] incompatibleDependencies The dependencies that are incompatible with the targets for building the
 *			composition.
 */
void VuoCompiler::getDependenciesRecursively(const string &dependency,
											 set<string> &compatibleDependencies, set<string> &incompatibleDependencies)
{
	map<string, int> dependencies = getDependenciesRecursivelyWithCache(dependency, vector<string>());

	for (map<string, int>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		if (i->second == 0)
			compatibleDependencies.insert(i->first);
		else
			incompatibleDependencies.insert(i->first);
	}
}

/**
 * Helper for the other getDependenciesRecursively() function.
 *
 * Returns a structure of dependencies visited, including @a dependency, where:
 *    - 0 = compatible
 *    - 1 = incompatible
 *    - 2 = compatibility not yet known
 *
 * Adds the dependencies visited to the cache (compatibleDependenciesCache and incompatibleDependenciesCache).
 */
map<string, int> VuoCompiler::getDependenciesRecursivelyWithCache(const string &dependency, const vector<string> &ancestorsVisited)
{
	map<string, int> dependenciesForSelf;

	// Check if already visited (circular dependency).
	vector<string>::const_iterator av = find(ancestorsVisited.begin(), ancestorsVisited.end(), dependency);
	if (av != ancestorsVisited.end())
	{
		dependenciesForSelf[dependency] = 2;
		return dependenciesForSelf;
	}

	// Check if already cached.
	map<string, set<string> >::iterator cd = compatibleDependenciesCache.find(dependency);
	map<string, set<string> >::iterator icd = incompatibleDependenciesCache.find(dependency);
	if (cd != compatibleDependenciesCache.end() || icd != incompatibleDependenciesCache.end())
	{
		if (cd != compatibleDependenciesCache.end())
			for (set<string>::iterator i = cd->second.begin(); i != cd->second.end(); ++i)
				dependenciesForSelf[*i] = 0;
		if (icd != incompatibleDependenciesCache.end())
			for (set<string>::iterator i = icd->second.begin(); i != icd->second.end(); ++i)
				dependenciesForSelf[*i] = 1;
		return dependenciesForSelf;
	}

	// If the composition was compiled with a different VuoCompiler instance, then node classes
	// that were generated at compile time need to be re-generated for this VuoCompiler instance.
	VuoCompilerNodeClass *nodeClass = getNodeClass(dependency);

	// See if the dependency is a node class, type, or library module, and therefore may have its
	// own dependencies.
	VuoCompilerModule *module = nodeClass ? nodeClass : getModule(dependency);

	bool isCompatible = true;
	if (module)
	{
		// Determine if the dependency is compatible with the targets.
		VuoCompilerTargetSet compositionTargets;
		compositionTargets.restrictToCurrentOperatingSystemVersion();
		isCompatible = module->getCompatibleTargets().isCompatibleWithAllOf(compositionTargets);

		// Add the dependencies of the dependency.
		vector<string> ancestorsAndSelfVisited = ancestorsVisited;
		ancestorsAndSelfVisited.push_back(dependency);
		set<string> children = module->getDependencies();
		for (set<string>::iterator i = children.begin(); i != children.end(); ++i)
		{
			string child = *i;

			map<string, int> dependenciesForChild = getDependenciesRecursivelyWithCache(child, ancestorsAndSelfVisited);
			dependenciesForSelf.insert(dependenciesForChild.begin(), dependenciesForChild.end());

			for (map<string, int>::iterator j = dependenciesForChild.begin(); j != dependenciesForChild.end(); ++j)
				if (j->second == 1)
					isCompatible = false;
		}
	}

	dependenciesForSelf[dependency] = isCompatible ? 0 : 1;

	set<string> compatibleDependenciesForSelf;
	set<string> incompatibleDependenciesForSelf;
	for (map<string, int>::iterator i = dependenciesForSelf.begin(); i != dependenciesForSelf.end(); ++i)
	{
		if (i->second == 0 || i->second == 2)
			compatibleDependenciesForSelf.insert(i->first);
		else if (i->second == 1)
			incompatibleDependenciesForSelf.insert(i->first);
	}

	// Add this dependency to the cache.
	compatibleDependenciesCache[dependency].insert( compatibleDependenciesForSelf.begin(), compatibleDependenciesForSelf.end() );
	incompatibleDependenciesCache[dependency].insert( incompatibleDependenciesForSelf.begin(), incompatibleDependenciesForSelf.end() );

	// Update other dependencies in the cache that skipped this dependency because it wasn't fully visited yet.
	for (map<string, int>::iterator i = dependenciesForSelf.begin(); i != dependenciesForSelf.end(); ++i)
	{
		string child = i->first;

		if (compatibleDependenciesCache[child].find(dependency) != compatibleDependenciesCache[child].end())
		{
			if (! isCompatible)
				compatibleDependenciesCache[child].erase(dependency);

			compatibleDependenciesCache[child].insert( compatibleDependenciesForSelf.begin(), compatibleDependenciesForSelf.end() );
			incompatibleDependenciesCache[child].insert( incompatibleDependenciesForSelf.begin(), incompatibleDependenciesForSelf.end() );
		}
	}

	return dependenciesForSelf;
}

/**
 * From a list of names of dependencies, gets the modules, library paths, and frameworks
 * to be passed to the linker.
 */
void VuoCompiler::getLinkerInputs(const set<string> &dependencies, bool shouldUseCachedResources,
								  set<Module *> &modules, set<string> &libraries, set<string> &frameworks)
{
	if (shouldUseCachedResources)
		getCachedResources();

	// Use separate linkers for custom versus system search paths to control the order in which paths are searched.
	// Linker::addPaths() adds paths to the end, but Linker::addSystemPaths() adds them to the beginning.
	__block Linker *linker;
	__block Linker *systemLinker;
	vector<string> librarySearchPaths = combinedEnvironment.getLibrarySearchPaths();
	dispatch_sync(llvmQueue, ^{
					  linker = new Linker("", "", getGlobalContext());
					  linker->addPaths(librarySearchPaths);
					  systemLinker = new Linker("", "", getGlobalContext());
					  systemLinker->addSystemPaths();
				  });

	for (set<string>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		string dependency = *i;

		if (shouldUseCachedResources && cachedResources.find(dependency) != cachedResources.end())
			libraries.insert(cachedResourceDylib);
		else
		{
			VuoCompilerModule *module = getModule(dependency);
			if (module)
				modules.insert(module->getModule());
			else
			{
				if (VuoStringUtilities::endsWith(dependency, ".framework"))
					frameworks.insert(dependency);
				else
				{
					__block sys::Path dependencyPath;
					dispatch_sync(llvmQueue, ^{
									  dependencyPath = linker->FindLib(dependency);
								  });
					if (dependencyPath.isEmpty())
						dispatch_sync(llvmQueue, ^{
										  dependencyPath = systemLinker->FindLib(dependency);
									  });
					if (! dependencyPath.isEmpty())
						libraries.insert(dependencyPath.str());
					else
						VLog("Warning: Could not locate dependency '%s'.", dependency.c_str());
				}
			}
		}
	}

	dispatch_sync(llvmQueue, ^{
					  delete linker;
					  delete systemLinker;
				  });
}

/**
 * Initializes cachedResourceDylib and cachedResources (if they haven't been already), allowing
 * them to be used when linking compositions.
 *
 * This function creates (or references, if it already exists and is up to date) a dynamic library
 * that contains:
 *   - all node classes, types, and library modules in the shared environment, except those that
 *     are premium or incompatible with the current operating system
 *   - their dependencies
 *   - the core dependencies needed by every composition
 *
 * If the dynamic library can't be created, cachedResourceDylib and cachedResources are unchanged upon return.
 *
 * @threadNoQueue{cachedResourcesQueue}
 */
void VuoCompiler::getCachedResources(void)
{
	dispatch_sync(cachedResourcesQueue, ^{
					  getCachedResourcesThreadUnsafe();
				  });
}

/**
 * Version of getCachedResources() that doesn't wrap its code in cachedResourcesQueue.
 *
 * @threadQueue{cachedResourcesQueue}
 */
void VuoCompiler::getCachedResourcesThreadUnsafe(void)
{
	if (! hasTriedCachedResources)
	{
		hasTriedCachedResources = true;
		cachedResources.clear();


		// Part 1: Construct the list of resources expected to be in the cache.

		set<string> expectedResources;
		set<Module *> modules;
		set<string> libraries;
		set<string> frameworks;

		// Add the loaded modules, the core dependencies, and their dependencies to the list.

		Environment *env = getSharedEnvironment();
		loadModulesIfNeeded();

		map<string, VuoCompilerModule *> allModules;
		map<string, VuoCompilerNodeClass *> nodeClasses = env->getNodeClasses();
		map<string, VuoCompilerType *> types = env->getTypes();
		map<string, VuoCompilerModule *> libraryModules = env->getLibraryModules();
		allModules.insert(nodeClasses.begin(), nodeClasses.end());
		allModules.insert(types.begin(), types.end());
		allModules.insert(libraryModules.begin(), libraryModules.end());

		set<string> dependencies;
		for (map<string, VuoCompilerModule *>::iterator i = allModules.begin(); i != allModules.end(); ++i)
		{
			string moduleKey = i->first;
			VuoCompilerModule *module = i->second;

			if (module->getPremium())
				continue;

			set<string> dependenciesToAdd;
			set<string> incompatibleDependencies;
			getDependenciesRecursively(moduleKey, dependenciesToAdd, incompatibleDependencies);

			if (incompatibleDependencies.empty())
			{
				dependencies.insert(dependenciesToAdd.begin(), dependenciesToAdd.end());
				expectedResources.insert(moduleKey);
			}
		}

		vector<string> coreDependencies = getCoreVuoDependencies();
		dependencies.insert(coreDependencies.begin(), coreDependencies.end());

		for (set<string>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
		{
			string dependency = *i;
			set<string> dependencySet;
			dependencySet.insert(dependency);

			set<Module *> modulesToAdd;
			set<string> librariesToAdd;
			set<string> frameworksToAdd;
			getLinkerInputs(dependencySet, false, modulesToAdd, librariesToAdd, frameworksToAdd);

			modules.insert(modulesToAdd.begin(), modulesToAdd.end());
			libraries.insert(librariesToAdd.begin(), librariesToAdd.end());
			frameworks.insert(frameworksToAdd.begin(), frameworksToAdd.end());

			if (! modulesToAdd.empty())
				expectedResources.insert(dependency);
			else if (! librariesToAdd.empty())
			{
				sys::Path libraryPath(*librariesToAdd.begin());
				if (libraryPath.isArchive() || libraryPath.isBitcodeFile())
					expectedResources.insert(dependency);
			}
		}


		// Part 2: Check if the cache contains an up-to-date version of each of the expected resources.

		string cacheDir = VuoFileUtilities::getCachePath();
		const string cacheFileName = "libVuoResources.dylib";
		const string indexFileName = "index.txt";
		string cacheFilePath = cacheDir + "/" + cacheFileName;
		string indexFilePath = cacheDir + "/" + indexFileName;
		const char separator = '\n';
		bool isCacheUpToDate = true;


		// Check if the cached files exist. If not, create them (without affecting their last modified date).
		bool cacheDirExists = VuoFileUtilities::fileExists(cacheDir);
		if (! cacheDirExists)
			VuoFileUtilities::makeDir(cacheDir);
		bool cacheFileExists = cacheDirExists && VuoFileUtilities::fileExists(cacheFilePath);
		if (! cacheFileExists)
			VuoFileUtilities::createFile(cacheFilePath);
		bool indexFileExists = cacheDirExists && VuoFileUtilities::fileExists(indexFilePath);
		if (! indexFileExists)
			VuoFileUtilities::createFile(indexFilePath);
		if (! cacheFileExists || ! indexFileExists)
			isCacheUpToDate = false;

		// Lock the cached files for reading. The lock remain active until the process exits.
		VuoFileUtilities::File cacheFile(cacheDir, cacheFileName);
		cacheFile.lockForReading();

		// Check if the cached dylib file is newer than all of the loaded modules and libraries.
		if (isCacheUpToDate)
		{
			unsigned long cacheFileLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(cacheFilePath);

			set<string> searchPaths;
			vector<string> moduleSearchPaths = env->getModuleSearchPaths();
			vector<string> librarySearchPaths = env->getLibrarySearchPaths();
			searchPaths.insert(moduleSearchPaths.begin(), moduleSearchPaths.end());
			searchPaths.insert(librarySearchPaths.begin(), librarySearchPaths.end());
			for (set<string>::iterator i = searchPaths.begin(); i != searchPaths.end() && isCacheUpToDate; ++i)
			{
				string searchPath = *i;

				/// @todo Search recursively - https://b33p.net/kosada/node/2468
				set<VuoFileUtilities::File *> files = VuoFileUtilities::findAllFilesInDirectory(searchPath);
				for (set<VuoFileUtilities::File *>::iterator j = files.begin(); j != files.end(); ++j)
				{
					string filePath = searchPath + "/" + (*j)->getRelativePath();
					unsigned long fileLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(filePath);
					if (fileLastModified > cacheFileLastModified)
					{
						isCacheUpToDate = false;
						break;
					}
				}

				for (set<VuoFileUtilities::File *>::iterator j = files.begin(); j != files.end(); ++j)
					delete *j;
			}
		}

		// Check if the cached index file matches the list of loaded modules and libraries.
		vector<string> indexedResources;
		if (isCacheUpToDate)
		{
			VuoFileUtilities::File indexFile(cacheDir, indexFileName);
			string index = indexFile.getContentsAsString();
			indexedResources = VuoStringUtilities::split(index, separator);

			if (indexedResources.size() != expectedResources.size())
			{
				isCacheUpToDate = false;
			}
			else
			{
				for (vector<string>::iterator i = indexedResources.begin(); i != indexedResources.end(); ++i)
				{
					if (expectedResources.find(*i) == expectedResources.end())
					{
						isCacheUpToDate = false;
						break;
					}
				}
			}
		}


		// Part 3: If the cache is not up to date, (re)create it.

		try
		{
			if (isCacheUpToDate)
			{
				cachedResources.insert(indexedResources.begin(), indexedResources.end());
			}
			else
			{
				// Try to upgrade the file lock for writing.
				bool gotLock = cacheFile.lockForWriting(true);

				if (gotLock)
				{
					// Link the dependencies to create the cached resources dylib.
					link(cacheFilePath, modules, libraries, frameworks, true);

					// Write the list of dependencies to the cached index.
					vector<string> expectedResourcesVector(expectedResources.begin(), expectedResources.end());
					string index = VuoStringUtilities::join(expectedResourcesVector, separator);
					VuoFileUtilities::writeStringToFile(index, indexFilePath);

					// Downgrade the file lock back to reading.
					cacheFile.lockForReading();

					cachedResources = expectedResources;
				}
				else
				{
					// Some other process is using the cached files, so this process will use them, too,
					// even though they're out of date.
					cachedResources.insert(indexedResources.begin(), indexedResources.end());
				}
			}

			cachedResourceDylib = cacheFilePath;
		}
		catch (VuoCompilerException &e)
		{
			VLog("Warning: Could not create the cache for the \"faster build\" optimization: %s", e.what());
		}
	}
}

/**
 * Asynchronously prepares the cache that enables compositions to build faster.
 *
 * The first time a composition is built with the "faster build" optimization, it waits until the cache
 * is prepared. Preparing the cache may take several seconds. By calling this function, the cache can be
 * prepared in advance, so that there's no delay when building the first composition.
 */
void VuoCompiler::prepareForFastBuild(void)
{
	dispatch_async(cachedResourcesQueue, ^{
					   getCachedResourcesThreadUnsafe();
				   });
}

/**
 * Links the given modules, libraries, and frameworks to create an executable or dynamic library.
 *
 * @param outputPath The resulting executable or dynamic library.
 * @param modules The LLVM modules to link in.
 * @param libraries The libraries to link in. If building an executable, one of them should contain a main function.
 * @param frameworks The frameworks to link in.
 * @param isDylib If true, the output file will be a dynamic library. Otherwise, it will be an executable.
 * @param rPath The @c -rpath argument to be passed to clang. If empty, the folder containing the Vuo framework on the build system will be used.
 * @throw VuoCompilerException clang or ld failed to link the given dependencies.
 */
void VuoCompiler::link(string outputPath, const set<Module *> &modules, const set<string> &libraries, const set<string> &frameworks, bool isDylib, string rPath)
{
	// http://stackoverflow.com/questions/11657529/how-to-generate-an-executable-from-an-llvmmodule


	// Write all the modules with renamed symbols to a composite module file (since the linker can't operate on in-memory modules).
	string compositeModulePath = VuoFileUtilities::makeTmpFile("composite", "bc");
	dispatch_sync(llvmQueue, ^{
					  Module *compositeModule = new Module("composite", getGlobalContext());
					  setTargetForModule(compositeModule);
					  for (set<Module *>::const_iterator i = modules.begin(); i != modules.end(); ++i)
					  {
						  string error;
						  if (Linker::LinkModules(compositeModule, *i, Linker::PreserveSource, &error))
						  VLog("Error: Failed to link compositeModule: %s", error.c_str());
					  }
					  writeModuleToBitcode(compositeModule, compositeModulePath);
					  delete compositeModule;
				  });


	// llvm-3.1/llvm/tools/clang/tools/driver/driver.cpp

	llvm::sys::Path clangPath = getClangPath();

	vector<const char *> args;
	args.push_back(clangPath.c_str());

	args.push_back(compositeModulePath.c_str());

	vector<string> coreDependencies = getCoreVuoDependencies();
	for (set<string>::const_iterator i = libraries.begin(); i != libraries.end(); ++i)
	{
		string library = *i;

		for (vector<string>::iterator j = coreDependencies.begin(); j != coreDependencies.end(); ++j)
		{
			string coreDependency = *j;
			if (VuoStringUtilities::endsWith(library, "lib" + coreDependency + ".a"))
				args.push_back("-force_load");  // Load all symbols of static core dependencies, not just those used in the objects.
		}

		args.push_back(library.c_str());
	}

	// Add framework search paths
	vector<string> frameworkArguments;

	vector<string> frameworkSearchPaths = combinedEnvironment.getFrameworkSearchPaths();
	for (vector<string>::const_iterator i = frameworkSearchPaths.begin(); i != frameworkSearchPaths.end(); ++i)
	{
		string a = "-F"+*i;
		// Keep these std::strings around until after args is done being used, since the std::string::c_str() is freed when the std::string is deleted.
		frameworkArguments.push_back(a);
		args.push_back(a.c_str());
	}

	for (set<string>::const_iterator i = frameworks.begin(); i != frameworks.end(); ++i)
	{
		args.push_back("-framework");

		string frameworkName = *i;
		frameworkName = frameworkName.substr(0, frameworkName.length() - string(".framework").length());
		args.push_back(strdup(frameworkName.c_str()));
	}

	// Check for C Runtime path within Vuo.framework
	llvm::sys::Path cRuntimePath;
	llvm::sys::Path crt1Path;
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	string vuoFrameworkContainingFolder = vuoFrameworkPath + "/..";
	if (! vuoFrameworkPath.empty())
	{
		cRuntimePath = vuoFrameworkPath + "/Modules/";
		crt1Path = cRuntimePath;
		crt1Path.appendComponent("crt1.o");
	}

	// If we have located a bundled version of crt1.o, link it in explicitly rather than relying on
	// clang's heuristic to locate a system version.
	if (!isDylib && crt1Path.canRead())
	{
		args.push_back("-nostartfiles");
		args.push_back(crt1Path.c_str());
	}

	// Linker option necessary for compatibility with our bundled version of ld64:
	args.push_back("-Xlinker");
	args.push_back("--no-demangle");

	// Avoid generating unknown load commands.
	// http://www.cocoabuilder.com/archive/xcode/308488-load-commands-in-10-7-dylib-block-install-name-tool-on-10-6.html
	args.push_back("-Xlinker");
	args.push_back("-no_function_starts");
	args.push_back("-Xlinker");
	args.push_back("-no_version_load_command");

	if (isVerbose)
		args.push_back("-v");

	if (isDylib)
		args.push_back("-dynamiclib");

	// Tell the built dylib/executable where to find Vuo.framework
	/// @todo Once we can build app bundles (https://b33p.net/kosada/node/3362), copy only the needed dynamic dependencies into the app bundle, and change the rpath accordingly
	args.push_back("-rpath");
	string rPathArg = (!rPath.empty()? rPath : vuoFrameworkContainingFolder);
	args.push_back(rPathArg.c_str());

	// Allow clang to print meaningful error messages.
	clang::DiagnosticOptions *diagOptions = new clang::DiagnosticOptions();
	clang::TextDiagnosticPrinter *diagClient = new clang::TextDiagnosticPrinter(llvm::errs(), diagOptions);
	diagClient->setPrefix(clangPath.str());
	IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
	clang::DiagnosticsEngine Diags(DiagID, diagOptions, diagClient);

	clang::driver::Driver TheDriver(args[0], "x86_64-apple-macosx10.6.0", outputPath, true, Diags);

	TheDriver.CCCIsCXX = true;  // clang++ instead of clang

	OwningPtr<clang::driver::Compilation> C(TheDriver.BuildCompilation(args));

	int Res = 0;
	const clang::driver::Command *FailingCommand = 0;
	if (C)
		Res = TheDriver.ExecuteCompilation(*C, FailingCommand);

	// Clean up composite module file.
	remove(compositeModulePath.c_str());

	if (Res != 0)
	{
		vector<string> thirdPartyNodeClasses;
		map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
		for (map<string, VuoCompilerNodeClass *>::const_iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
		{
			string nodeClassName = i->first;
			if (! VuoStringUtilities::beginsWith(nodeClassName, "vuo."))
				thirdPartyNodeClasses.push_back(nodeClassName);
		}

		string details = "One or more nodes in this composition can't be used by this version of Vuo. ";
		if (! thirdPartyNodeClasses.empty())
		{
			details += "Make sure you're using the latest version of all the extra Vuo nodes you've installed:\n";
			sort(thirdPartyNodeClasses.begin(), thirdPartyNodeClasses.end());
			for (vector<string>::iterator i = thirdPartyNodeClasses.begin(); i != thirdPartyNodeClasses.end(); ++i)
				details += " • " + *i + "\n";
		}
		details += "Check the Console application for messages with more information about the problem.";

		vector<VuoCompilerError> errors;
		VuoCompilerError error("Node outdated or broken", details, set<VuoNode *>(), set<VuoCable *>());
		errors.push_back(error);
		throw VuoCompilerException(errors);
	}
}

/**
 * Returns the LLVM module read from the node class, type, or library implementation at @c inputPath (a .c file).
 */
Module * VuoCompiler::readModuleFromC(string inputPath)
{
	return readModuleFromC(inputPath, vector<string>());
}

/**
 * Returns the LLVM module read from the node class, type, or library implementation at @c inputPath (a .c file).
 */
Module * VuoCompiler::readModuleFromC(string inputPath, const vector<string> &extraArgs)
{
	// llvm-3.1/llvm/tools/clang/examples/clang-interpreter/main.cpp

	vector<const char *> args;
	args.push_back(inputPath.c_str());
	args.push_back("-DVUO_COMPILER");
	args.push_back("-fblocks");

	vector<string> headerSearchPaths = combinedEnvironment.getHeaderSearchPaths();
	for (vector<string>::iterator i = headerSearchPaths.begin(); i != headerSearchPaths.end(); ++i)
	{
		args.push_back("-I");
		args.push_back(i->c_str());
	}

	if (isVerbose)
		args.push_back("-v");

	for (vector<string>::const_iterator i = extraArgs.begin(); i != extraArgs.end(); ++i)
		args.push_back(i->c_str());

	clang::DiagnosticOptions * diagOptions = new clang::DiagnosticOptions();
	IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
	clang::DiagnosticsEngine Diags(DiagID, diagOptions);

	OwningPtr<clang::CompilerInvocation> CI(new clang::CompilerInvocation);
	clang::CompilerInvocation::CreateFromArgs(*CI, &args[0], &args[0] + args.size(), Diags);

	clang::CompilerInstance Clang;
	Clang.setInvocation(CI.take());

	Clang.createDiagnostics(args.size(), &args[0]);
	if (!Clang.hasDiagnostics())
		return NULL;

	// See CompilerInvocation::GetResourcesPath -- though we're not calling it because we don't have MainAddr.
	llvm::sys::Path clangPath = getClangPath();
	llvm::sys::Path builtinHeaderSearchPath = clangPath;
	builtinHeaderSearchPath.eraseComponent();  // Remove /clang from foo/bin/clang
	builtinHeaderSearchPath.eraseComponent();  // Remove /bin   from foo/bin
	builtinHeaderSearchPath.appendComponent("lib");
	builtinHeaderSearchPath.appendComponent("clang");
	builtinHeaderSearchPath.appendComponent(CLANG_VERSION_STRING);  // foo/lib/clang/<version>
	Clang.getHeaderSearchOpts().ResourceDir = builtinHeaderSearchPath.str();

//	OwningPtr<clang::CodeGenAction> Act(new clang::EmitLLVMOnlyAction());  // @@@ return value of takeModule() is destroyed at the end of this function
	clang::CodeGenAction *Act = new clang::EmitLLVMOnlyAction();
	if (!Clang.ExecuteAction(*Act))
		return NULL;

	return Act->takeModule();
}

/**
 * Returns the LLVM module read from @a inputPath (an LLVM bitcode file).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcode(string inputPath)
{
	string dir, file, ext;
	VuoFileUtilities::splitPath(inputPath, dir, file, ext);
	VuoFileUtilities::File inputFile(dir, file + "." + ext);
	return readModuleFromBitcode(&inputFile);
}

/**
 * Returns the LLVM module read from @a inputFile (an LLVM bitcode file).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcode(VuoFileUtilities::File *inputFile)
{
	size_t inputDataBytes;
	char *inputData = inputFile->getContentsAsRawData(inputDataBytes);

	string error;
	Module *module = readModuleFromBitcodeData(inputData, inputDataBytes, error);
	if (! module)
		VLog("Error: Couldn't parse module '%s': %s.", inputFile->getRelativePath().c_str(), error.c_str());

	free(inputData);

	return module;
}

/**
 * Returns the LLVM module read from @a inputData (a data buffer of size @a inputDataBytes).
 *
 * @threadNoQueue{llvmQueue}
 */
Module * VuoCompiler::readModuleFromBitcodeData(char *inputData, size_t inputDataBytes, string &error)
{
	__block Module *module;
	dispatch_sync(llvmQueue, ^{
					  StringRef inputDataAsStringRef(inputData, inputDataBytes);
					  MemoryBuffer *mb = MemoryBuffer::getMemBuffer(inputDataAsStringRef, "", false);
					  module = ParseBitcodeFile(&(*mb), getGlobalContext(), &error);
					  delete mb;
				  });
	return module;
}

/**
 * Calls the destructor for @a module, using the LLVM global context thread-safely.
 *
 * @threadNoQueue{llvmQueue}
 */
void VuoCompiler::deleteModule(Module *module)
{
	dispatch_sync(llvmQueue, ^{
					  delete module;
				  });
}

/**
 * Returns the set of premium module names that the compiler has attempted to load,
 * whether or not the loads were successful.
 */
set<string> VuoCompiler::getEncounteredPremiumModules()
{
	return encounteredPremiumModules;
}

/**
 * Verifies the LLVM module and writes it to @a outputPath (an LLVM bitcode file).
 *
 * Returns true if there was a problem verifying or writing the module.
 *
 * @threadQueue{llvmQueue}
 */
bool VuoCompiler::writeModuleToBitcode(Module *module, string outputPath)
{
	if (verifyModule(*module, PrintMessageAction))
	{
		VLog("Error: Module verification failed.");
		return true;
	}

	string err;
	raw_fd_ostream out(outputPath.c_str(), err);
	if (! err.empty())
	{
		VLog("Error: Couldn't open file '%s' for writing: %s", outputPath.c_str(), err.c_str());
		return true;
	}
	WriteBitcodeToFile(module, out);

	return false;
}

/**
 * Sets the target triple for @c module. If @c target is empty, uses the target triple of the host machine.
 *
 * @threadQueue{llvmQueue}
 */
void VuoCompiler::setTargetForModule(Module *module, string target)
{
/*
	string effectiveTarget = target;
	if (effectiveTarget.empty())
	{
		// llvm::sys::getDefaultTargetTriple() finds a target based on the host, but the "default" target is not necessarily the
		// same target that results from invoking command-line clang without a -target argument. That is the "effective" target.
		// For example, the "default" target could be x86_64-apple-darwin10.8.0 and the "effective" target could be x86_64-apple-macosx10.6.0.

		llvm::sys::Path clangPath = getClangPath();

		vector<const char *> args;
		args.push_back(clangPath.c_str());
		args.push_back("/bin/sh");  // Driver needs an input file (that exists) or it refuses to give you the correct effective target.

		clang::DiagnosticOptions * diagOptions = new clang::DiagnosticOptions();
		IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagID(new clang::DiagnosticIDs());
		clang::DiagnosticsEngine Diags(DiagID, diagOptions);

		clang::driver::Driver TheDriver(args[0], llvm::sys::getDefaultTargetTriple(), "a.out", true, Diags);
		OwningPtr<clang::driver::Compilation> C(TheDriver.BuildCompilation(args));
		effectiveTarget = C->getDefaultToolChain().ComputeEffectiveClangTriple(C->getArgs());
	}

	module->setTargetTriple(effectiveTarget);
*/
	module->setTargetTriple("x86_64-apple-macosx10.6.0");
}

/**
 * Instantiates a node for the given node class.
 *
 * If the node class is a generic template (e.g. vuo.data.hold), then the node is instantiated with the specialized
 * version of the node class (e.g. vuo.data.hold.VuoGenericType1).
 *
 * @param nodeClass The node class from which to create the node.
 * @param title The node's title.
 * @param x The node's x-coordinate within the composition.
 * @param y The node's y-coordinate within the composition.
 */
VuoNode * VuoCompiler::createNode(VuoCompilerNodeClass *nodeClass, string title, double x, double y)
{
	vector<string> genericTypes = VuoCompilerSpecializedNodeClass::getGenericTypeNamesFromPorts(nodeClass);

	if (genericTypes.empty() || dynamic_cast<VuoCompilerSpecializedNodeClass *>(nodeClass))
		return nodeClass->newNode(title, x, y);
	else
	{
		string genericNodeClassName = nodeClass->getBase()->getClassName();
		string genericNodeClassNameWithSuffixes = VuoCompilerSpecializedNodeClass::createSpecializedNodeClassName(genericNodeClassName, genericTypes);
		VuoCompilerNodeClass *genericNodeClass = getNodeClass(genericNodeClassNameWithSuffixes);
		VuoCompilerSpecializedNodeClass *genericNodeClassAsSpecialized = static_cast<VuoCompilerSpecializedNodeClass *>(genericNodeClass);
		string specializedNodeClassName = genericNodeClassAsSpecialized->createDefaultSpecializedNodeClassName();
		VuoCompilerNodeClass *specializedNodeClass = getNodeClass(specializedNodeClassName);
		return specializedNodeClass->newNode(title, x, y);
	}
}

/**
 * Looks up the VuoCompilerNodeClass for the node class specified by @a id.
 *
 * The node class module is loaded or generated if it hasn't been already.
 *
 * @eg{
 *		VuoCompiler *compiler = new VuoCompiler();
 *		VuoCompilerNodeClass *nc = compiler->getNodeClass("vuo.math.add.VuoInteger");
 *		[...]
 *		delete compiler;
 * }
 */
VuoCompilerNodeClass * VuoCompiler::getNodeClass(const string &id)
{
	loadModulesIfNeeded();

	VuoCompilerNodeClass *nodeClass = NULL;

	map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
	map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(id);
	if (nodeClassIter != nodeClasses.end())
		nodeClass = nodeClassIter->second;
	else
	{
		VuoNodeClass *baseNodeClass = VuoCompilerMakeListNodeClass::newNodeClass(id, this, llvmQueue);
		if (! baseNodeClass)
			baseNodeClass = VuoCompilerSpecializedNodeClass::newNodeClass(id, this, llvmQueue);

		if (baseNodeClass)
		{
			nodeClass = baseNodeClass->getCompiler();
			combinedEnvironment.addNodeClassToCombinedEnvironment( nodeClass, &myEnvironment, getSharedEnvironment() );
		}
	}

	return nodeClass;
}

/**
 * Returns a map linking a string representation of a node class's name to its VuoCompilerNodeClass instance.
 *
 * The node class modules are loaded if they haven't been already.
 */
map<string, VuoCompilerNodeClass *> VuoCompiler::getNodeClasses()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getNodeClasses();
}

/**
 * Looks up the VuoCompilerType for the port type specified by @a id.
 *
 * The port type module is loaded or generated if it haven't been already.
 */
VuoCompilerType * VuoCompiler::getType(const string &id)
{
	loadModulesIfNeeded();

	__block VuoCompilerType *type = NULL;

	map<string, VuoCompilerType *> types = combinedEnvironment.getTypes();
	map<string, VuoCompilerType *>::iterator typeIter = types.find(id);
	if (typeIter != types.end())
		type = typeIter->second;
	else if (VuoGenericType::isGenericTypeName(id))
	{
		VuoGenericType *genericType = new VuoGenericType(id, set<string>());
		dispatch_sync(llvmQueue, ^{
						  type = VuoCompilerGenericType::newGenericType(genericType, this);
					  });
	}

	return type;
}

/**
 * Returns a map linking a string representation of a type's id to its VuoCompilerType instance.
 *
 * The type modules are loaded if they haven't been already.
 */
map<string, VuoCompilerType *> VuoCompiler::getTypes()
{
	loadModulesIfNeeded();

	return combinedEnvironment.getTypes();
}

/**
 * Looks up the VuoNodeSet with the given @c name.
 *
 * The node class modules are loaded if they haven't been already.
 */
VuoNodeSet * VuoCompiler::getNodeSetForName(const string &name)
{
	loadModulesIfNeeded();

	return combinedEnvironment.findNodeSet(name);
}

/**
 * Looks up the VuoCompilerNodeClass, VuoCompilerType, or VuoCompilerModule specified by @a id.
 */
VuoCompilerModule * VuoCompiler::getModule(const string &id)
{
	VuoCompilerModule *module = NULL;

	map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
	map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(id);
	if (nodeClassIter != nodeClasses.end())
		module = nodeClassIter->second;
	else
	{
		map<string, VuoCompilerType *> types = combinedEnvironment.getTypes();
		map<string, VuoCompilerType *>::iterator typeIter = types.find(id);
		if (typeIter != types.end())
			module = typeIter->second;
		else
		{
			map<string, VuoCompilerModule *> libraryModules = combinedEnvironment.getLibraryModules();
			map<string, VuoCompilerModule *>::iterator libraryModuleIter = libraryModules.find(id);
			if (libraryModuleIter != libraryModules.end())
				module = libraryModuleIter->second;
		}
	}

	return module;
}

/**
 * Prints a list of all loaded node classes to standard output.
 *
 * The node class modules are loaded if they haven't been already.
 *
 * @param format The format for printing the node classes.
 *	- If "", prints each class name (e.g. vuo.math.count.VuoInteger), one per line.
 *	- If "path", prints the absolute path of each node class, one per line.
 *	- If "dot", prints the declaration of a node as it would appear in a .vuo (DOT format) file,
 *		with a constant value set for each data+event input port
 *		and a comment listing metadata and port types for the node class.
 */
void VuoCompiler::listNodeClasses(const string &format)
{
	loadModulesIfNeeded();

	map<string, VuoCompilerNodeClass *> nodeClasses = combinedEnvironment.getNodeClasses();
	for (map<string, VuoCompilerNodeClass *>::const_iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
	{
		VuoCompilerNodeClass *nodeClass = i->second;
		if (format == "")
		{
			printf("%s\n", nodeClass->getBase()->getClassName().c_str());
		}
		else if (format == "path")
		{
			// TODO
		}
		else if (format == "dot")
		{
			VuoCompilerNode *node = nodeClass->newNode()->getCompiler();

			printf("%s\n", nodeClass->getDoxygenDocumentation().c_str());
			printf("%s\n\n", node->getGraphvizDeclaration().c_str());

			delete node;
		}
	}
}

/**
 * Returns the file names of bitcode dependencies needed by every linked Vuo composition.
 */
vector<string> VuoCompiler::getCoreVuoDependencies(void)
{
	vector<string> dependencies;
	dependencies.push_back("VuoHeap");
	dependencies.push_back("VuoTelemetry.bc");
	dependencies.push_back("zmq");
	dependencies.push_back("gvc");
	dependencies.push_back("graph");
	dependencies.push_back("cdt");
	dependencies.push_back("pathplan");
	dependencies.push_back("xdot");
	dependencies.push_back("gvplugin_dot_layout");
	dependencies.push_back("gvplugin_core");
	dependencies.push_back("json");
	dependencies.push_back("objc");
	dependencies.push_back("c");
	dependencies.push_back("CoreFoundation.framework");
	dependencies.push_back("Foundation.framework");
	return dependencies;
}

/**
 * Returns the file name of the main function can accompany the Vuo runtime.
 */
string VuoCompiler::getRuntimeMainDependency(void)
{
	return "VuoRuntimeMain.bc";
}

/**
 * Returns the file name of the Vuo runtime.
 */
string VuoCompiler::getRuntimeDependency(void)
{
	return "VuoRuntime.bc";
}

/**
 * Returns the name of the library module that launches an application in the composition process.
 */
string VuoCompiler::getApplicationDependency(void)
{
	return "VuoWindow";
}

/**
 * Returns the path to the Clang binary.
 */
llvm::sys::Path VuoCompiler::getClangPath(void)
{
	return clangPath;
}

/**
 * Returns the name of the node class that would be located at @c path.
 */
string VuoCompiler::getModuleNameForPath(string path)
{
	string dir, file, extension;
	VuoFileUtilities::splitPath(path, dir, file, extension);
	return file;
}

/**
 * Adds a module search path (for node classes, types, and libraries) to use when linking a composition.
 */
void VuoCompiler::addModuleSearchPath(string path)
{
	myEnvironment.addModuleSearchPath(path);
	addLibrarySearchPath(path);
}

/**
 * Adds a header search path to use when compiling a node class.
 */
void VuoCompiler::addHeaderSearchPath(const string &path)
{
	myEnvironment.addHeaderSearchPath(path);
	combinedEnvironment.addHeaderSearchPath(path);
}

/**
 * Adds a library search path to use when linking a composition.
 */
void VuoCompiler::addLibrarySearchPath(const string &path)
{
	myEnvironment.addLibrarySearchPath(path);
	combinedEnvironment.addLibrarySearchPath(path);
}

/**
 * Adds a Mac OS X framework search path to use when linking a composition.
 */
void VuoCompiler::addFrameworkSearchPath(const string &path)
{
	myEnvironment.addFrameworkSearchPath(path);
	combinedEnvironment.addFrameworkSearchPath(path);
}

/**
 * Sets the telemetry option to use when compiling a composition. Valid values are "on" and "console".
 */
void VuoCompiler::setTelemetry(const string &telemetry)
{
	this->telemetry = telemetry;
}

/**
 * Sets the target triple to use when compiling or linking.
 */
void VuoCompiler::setTarget(const string &target)
{
	this->target = target;
}

/**
 * Sets the verbosity to use when compiling or linking. If true, prints some debug info and passes the `-v` option to Clang.
 */
void VuoCompiler::setVerbose(bool isVerbose)
{
	this->isVerbose = isVerbose;
}

/**
 * Sets the path to the clang binary.
 */
void VuoCompiler::setClangPath(const string &clangPath)
{
	this->clangPath = llvm::sys::Path(StringRef(clangPath));
}

/**
 * Returns the path to the VuoCompositionLoader executable.
 */
string VuoCompiler::getCompositionLoaderPath(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	return (vuoFrameworkPath.empty() ?
				VUO_ROOT "/runtime/VuoCompositionLoader" :
				vuoFrameworkPath + "/Helpers/VuoCompositionLoader.app/Contents/MacOS/VuoCompositionLoader");
}

/**
 * Returns the path to the VuoCompositionStub dynamic library.
 */
string VuoCompiler::getCompositionStubPath(void)
{
	string vuoFrameworkPath = VuoFileUtilities::getVuoFrameworkPath();
	return (vuoFrameworkPath.empty() ?
				VUO_ROOT "/base/VuoCompositionStub.dylib" :
				vuoFrameworkPath + "/Modules/VuoCompositionStub.dylib");
}

/**
 * Prints info about this compiler, for debugging.
 */
void VuoCompiler::print(void)
{
	fprintf(stderr, "Module (node class, type, library) search paths:\n");
	vector<string> moduleSearchPaths = combinedEnvironment.getModuleSearchPaths();
	for (vector<string>::iterator i = moduleSearchPaths.begin(); i != moduleSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Header search paths:\n");
	vector<string> headerSearchPaths = combinedEnvironment.getHeaderSearchPaths();
	for (vector<string>::iterator i = headerSearchPaths.begin(); i != headerSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Other library search paths:\n");
	vector<string> librarySearchPaths = combinedEnvironment.getLibrarySearchPaths();
	for (vector<string>::iterator i = librarySearchPaths.begin(); i != librarySearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Other framework search paths:\n");
	vector<string> frameworkSearchPaths = combinedEnvironment.getFrameworkSearchPaths();
	for (vector<string>::iterator i = frameworkSearchPaths.begin(); i != frameworkSearchPaths.end(); ++i)
		fprintf(stderr, " %s\n", (*i).c_str());
	fprintf(stderr, "Framework path:\n");
	if (! VuoFileUtilities::getVuoFrameworkPath().empty())
		fprintf(stderr, " %s\n", VuoFileUtilities::getVuoFrameworkPath().c_str());
	fprintf(stderr, "Clang path:\n");
	if (! getClangPath().str().empty())
		fprintf(stderr, " %s\n", getClangPath().c_str());
}

/**
 * Creates a runner object that can run the composition in file @a compositionFilePath in a new process.
 *
 * @throw std::exception The composition is invalid.
 */
VuoRunner * VuoCompiler::newSeparateProcessRunnerFromCompositionFile(string compositionFilePath)
{
	VuoCompiler compiler;
	string directory, file, extension;
	VuoFileUtilities::splitPath(compositionFilePath, directory, file, extension);
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile(file, "bc");
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile(file + "-linked", "");
	compiler.compileComposition(compositionFilePath, compiledCompositionPath);
	compiler.linkCompositionToCreateExecutable(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newSeparateProcessRunnerFromExecutable(linkedCompositionPath, directory, true);
}

/**
 * Creates a runner object that can run the composition in string @a composition in a new process.
 *
 * @param composition A serialized composition.
 * @param workingDirectory The directory used by nodes in the composition to resolve relative paths.
 * @throw std::exception The composition is invalid.
 */
VuoRunner * VuoCompiler::newSeparateProcessRunnerFromCompositionString(string composition, string workingDirectory)
{
	VuoCompiler compiler;
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "bc");
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition-linked", "");
	compiler.compileCompositionString(composition, compiledCompositionPath);
	compiler.linkCompositionToCreateExecutable(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newSeparateProcessRunnerFromExecutable(linkedCompositionPath, workingDirectory, true);
}

/**
 * Creates a runner object that can run the composition in file @a compositionFilePath in this process.
 *
 * @throw std::exception The composition is invalid.
 */
VuoRunner * VuoCompiler::newCurrentProcessRunnerFromCompositionFile(string compositionFilePath)
{
	VuoCompiler compiler;
	string directory, file, extension;
	VuoFileUtilities::splitPath(compositionFilePath, directory, file, extension);
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile(file, "bc");
	compiler.compileComposition(compositionFilePath, compiledCompositionPath);
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile(file, "dylib");
	compiler.linkCompositionToCreateDynamicLibrary(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newCurrentProcessRunnerFromDynamicLibrary(linkedCompositionPath, directory, true);
}

/**
 * Creates a runner object that can run the composition in string @a composition in this process.
 *
 * @param composition A serialized composition.
 * @param workingDirectory The directory used by nodes in the composition to resolve relative paths.
 * @throw std::exception The composition is invalid.
 */
VuoRunner * VuoCompiler::newCurrentProcessRunnerFromCompositionString(string composition, string workingDirectory)
{
	VuoCompiler compiler;
	string compiledCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "bc");
	compiler.compileCompositionString(composition, compiledCompositionPath);
	string linkedCompositionPath = VuoFileUtilities::makeTmpFile("VuoRunnerComposition", "dylib");
	compiler.linkCompositionToCreateDynamicLibrary(compiledCompositionPath, linkedCompositionPath, Optimization_FastBuild);
	remove(compiledCompositionPath.c_str());
	return VuoRunner::newCurrentProcessRunnerFromDynamicLibrary(linkedCompositionPath, workingDirectory, true);
}

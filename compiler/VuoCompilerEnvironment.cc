/**
 * @file
 * VuoCompilerEnvironment implementation.
 *
 * @copyright Copyright © 2012–2023 Kosada Incorporated.
 * This code may be modified and distributed under the terms of the GNU Lesser General Public License (LGPL) version 2 or later.
 * For more information, see https://vuo.org/license.
 */

#include "VuoCompilerEnvironment.hh"
#include "VuoCompiler.hh"
#include "VuoCompilerComposition.hh"
#include "VuoCompilerCompoundType.hh"
#include "VuoCompilerDelegate.hh"
#include "VuoCompilerException.hh"
#include "VuoCompilerGenericType.hh"
#include "VuoCompilerIssue.hh"
#include "VuoCompilerNodeClass.hh"
#include "VuoCompilerPortClass.hh"
#include "VuoCompilerSpecializedNodeClass.hh"
#include "VuoCompilerType.hh"
#include "VuoComposition.hh"
#include "VuoDependencyGraphVertex.hh"
#include "VuoDirectedAcyclicGraph.hh"
#include "VuoGenericType.hh"
#include "VuoMakeDependencies.hh"
#include "VuoModuleCache.hh"
#include "VuoModuleCompiler.hh"
#include "VuoModuleCompilationQueue.hh"
#include "VuoModuleInfo.hh"
#include "VuoModuleInfoIterator.hh"
#include "VuoNodeClass.hh"
#include "VuoNodeSet.hh"
#include "VuoPortClass.hh"
#include "VuoStringUtilities.hh"
#include "VuoType.hh"

/**
 * Creates an empty environment.
 */
VuoCompilerEnvironment::VuoCompilerEnvironment(string target, bool builtIn, bool generated)
	: target(target), builtIn(builtIn), generated(generated)
{
	inMemoryModuleAwaitingLoad = nullptr;
	compilersToNotifyQueue = dispatch_queue_create("org.vuo.compiler.notify", 0);
	moduleSearchPathContentsChangedQueue = dispatch_queue_create("org.vuo.compiler.watch", 0);
	dependencyGraph = new VuoDirectedAcyclicGraph();
	compositionDependencyGraph = new VuoDirectedAcyclicGraph();
	moduleCompilationQueue = new VuoModuleCompilationQueue();
}

/**
 * Destructor.
 */
VuoCompilerEnvironment::~VuoCompilerEnvironment(void)
{
	stopWatchingModuleSearchPaths();
	dispatch_sync(moduleSearchPathContentsChangedQueue, ^{});

	dispatch_release(moduleSearchPathContentsChangedQueue);
	dispatch_release(compilersToNotifyQueue);

	for (map<string, VuoCompilerNodeClass *>::iterator i = nodeClasses.begin(); i != nodeClasses.end(); ++i)
		VuoCompiler::destroyModule(i->second);

	for (map<string, VuoCompilerType *>::iterator i = types.begin(); i != types.end(); ++i)
		VuoCompiler::destroyModule(i->second);

	for (map<string, VuoCompilerModule *>::iterator i = libraryModules.begin(); i != libraryModules.end(); ++i)
		VuoCompiler::destroyModule(i->second);

	for (map<string, VuoNodeSet *>::iterator i = nodeSetForName.begin(); i != nodeSetForName.end(); ++i)
		delete i->second;

	for (map<string, map<string, VuoModuleInfo *> >::iterator i = moduleFilesAtSearchPath.begin(); i != moduleFilesAtSearchPath.end(); ++i)
		for (map<string, VuoModuleInfo *>::iterator j = i->second.begin(); j != i->second.end(); ++j)
			delete j->second;

	for (map<string, map<string, VuoModuleInfo *> >::iterator i = sourceFilesAtSearchPath.begin(); i != sourceFilesAtSearchPath.end(); ++i)
		for (map<string, VuoModuleInfo *>::iterator j = i->second.begin(); j != i->second.end(); ++j)
			delete j->second;

	delete dependencyGraph;
	delete compositionDependencyGraph;
}

/**
 * Returns this environment's LLVM target triple.
 */
string VuoCompilerEnvironment::getTarget()
{
	return target;
}

/**
 * Adds a compiler to notify when this VuoCompilerEnvironment loads/unloads modules as a result of changes to the watched search paths.
 */
void VuoCompilerEnvironment::addCompilerToNotify(VuoCompiler *compiler)
{
	dispatch_sync(compilersToNotifyQueue, ^{
					  compilersToNotify.insert(compiler);
				  });
}

/**
 * Removes a compiler to notify when this VuoCompilerEnvironment loads/unloads modules as a result of changes to the watched search paths.
 */
void VuoCompilerEnvironment::removeCompilerToNotify(VuoCompiler *compiler)
{
	dispatch_sync(compilersToNotifyQueue, ^{
					  compilersToNotify.erase(compiler);
				  });
}

/**
 * Returns the node classes loaded, plus specialized node classes generated by the compiler.
 */
map<string, VuoCompilerNodeClass *> VuoCompilerEnvironment::getNodeClasses(void)
{
	return nodeClasses;
}

/**
 * Returns the node class with the given @a moduleKey, or null if no node class by that name has been loaded.
 */
VuoCompilerNodeClass * VuoCompilerEnvironment::getNodeClass(const string &moduleKey)
{
	map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(moduleKey);
	if (nodeClassIter != nodeClasses.end())
		return nodeClassIter->second;

	return NULL;
}

/**
 * Returns the types loaded.
 */
map<string, VuoCompilerType *> VuoCompilerEnvironment::getTypes(void)
{
	return types;
}

/**
 * Returns the type with the given @a moduleKey, or null if no type by that name has been loaded.
 */
VuoCompilerType * VuoCompilerEnvironment::getType(const string &moduleKey)
{
	map<string, VuoCompilerType *>::iterator typeIter = types.find(moduleKey);
	if (typeIter != types.end())
		return typeIter->second;

	return NULL;
}

/**
 * Returns the node sets loaded.
 */
map<string, VuoNodeSet *> VuoCompilerEnvironment::getNodeSets(void)
{
	return nodeSetForName;
}

/**
 * Returns the library with the given `libraryModuleName`, or null if no library by that name has been loaded.
 */
VuoCompilerModule *VuoCompilerEnvironment::getLibraryModule(const string &libraryModuleName)
{
	map<string, VuoCompilerModule *>::iterator libraryIter = libraryModules.find(libraryModuleName);
	if (libraryIter != libraryModules.end())
		return libraryIter->second;

	return nullptr;
}

/**
 * Returns the library modules loaded.
 */
map<string, VuoCompilerModule *> VuoCompilerEnvironment::getLibraryModules(void)
{
	return libraryModules;
}

/**
 * Returns the VuoCompilerNodeClass, VuoCompilerType, or VuoCompilerModule with the given name,
 * or null if no such module has been loaded.
 */
VuoCompilerModule * VuoCompilerEnvironment::findModule(const string &moduleKey)
{
	map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(moduleKey);
	if (nodeClassIter != nodeClasses.end())
		return nodeClassIter->second;

	map<string, VuoCompilerType *>::iterator typeIter = types.find(moduleKey);
	if (typeIter != types.end())
		return typeIter->second;

	map<string, VuoCompilerModule *>::iterator libraryIter = libraryModules.find(moduleKey);
	if (libraryIter != libraryModules.end())
		return libraryIter->second;

	return NULL;
}

/**
 * Returns the node set with the given name, or null if no such node set been loaded.
 */
VuoNodeSet * VuoCompilerEnvironment::findNodeSet(const string &name)
{
	map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(name);
	if (nodeSetIter != nodeSetForName.end())
		return nodeSetIter->second;

	return NULL;
}

/**
 * Adds a search path for node classes, types, and library modules,
 * and starts watching it for changes.
 */
void VuoCompilerEnvironment::addModuleSearchPath(const string &path, bool shouldWatch)
{
	moduleSearchPaths.push_back(path);

	updateModulesAtSearchPath(path);
	updateSourceFilesAtSearchPath(path);

	if (shouldWatch)
		startWatchingModuleSearchPath(path);
}

/**
 * Returns the search paths for node classes, types, and library modules.
 */
vector<string> VuoCompilerEnvironment::getModuleSearchPaths(void)
{
	return moduleSearchPaths;
}

/**
 * Adds a search path for header/include files.
 */
void VuoCompilerEnvironment::addHeaderSearchPath(const string &path)
{
	headerSearchPaths.push_back(path);
}

/**
 * Returns the search paths for header/include files.
 */
vector<string> VuoCompilerEnvironment::getHeaderSearchPaths(void)
{
	return headerSearchPaths;
}

/**
 * Adds a search path for libraries (other than Vuo library modules).
 */
void VuoCompilerEnvironment::addLibrarySearchPath(const string &path)
{
	librarySearchPaths.push_back(path);
}

/**
 * Returns the search paths for libraries (other than Vuo library modules).
 */
vector<string> VuoCompilerEnvironment::getLibrarySearchPaths(void)
{
	return librarySearchPaths;
}

/**
 * Adds a search path for frameworks.
 */
void VuoCompilerEnvironment::addFrameworkSearchPath(const string &path)
{
	frameworkSearchPaths.push_back(path);
}

/**
 * Returns the search paths for frameworks.
 */
vector<string> VuoCompilerEnvironment::getFrameworkSearchPaths(void)
{
	return frameworkSearchPaths;
}

/**
 * Returns a full dependency graph for this environment, containing all modules that have been loaded and their dependencies.
 */
VuoDirectedAcyclicGraph * VuoCompilerEnvironment::getDependencyGraph(void)
{
	return dependencyGraph;
}

/**
 * Returns a partial dependency graph for this environment, containing all subcompositions (loaded or not) and the
 * node classes that are their direct dependencies.
 */
VuoDirectedAcyclicGraph * VuoCompilerEnvironment::getCompositionDependencyGraph(void)
{
	return compositionDependencyGraph;
}

/**
 * Sets the module cache used by this environment and enables this environment to load cached compiled modules.
 */
void VuoCompilerEnvironment::setModuleCache(shared_ptr<VuoModuleCache> moduleCache)
{
	this->moduleCache = moduleCache;

	if (moduleCache)
	{
		compiledModuleCachePath = moduleCache->getCompiledModulesPath(generated, VuoCompiler::getTargetArch(target));
		overriddenCompiledModuleCachePath = moduleCache->getOverriddenCompiledModulesPath(generated, VuoCompiler::getTargetArch(target));

		addModuleSearchPath(compiledModuleCachePath, false);
		addModuleSearchPath(overriddenCompiledModuleCachePath, false);
	}
	else
	{
		compiledModuleCachePath = "";
		overriddenCompiledModuleCachePath = "";
	}
}

/**
 * Returns the module cache used by this environment.
 */
shared_ptr<VuoModuleCache> VuoCompilerEnvironment::getModuleCache(void)
{
	return moduleCache;
}

/**
 * Returns the directory containing compiled/generated bitcode for subcompositions and text-code modules (if this is
 * an installed environment) or specialized modules (if this is a generated environment).
 */
string VuoCompilerEnvironment::getCompiledModuleCachePath(void)
{
	return compiledModuleCachePath;
}

/**
 * Returns the directory containing compiled bitcode for unsaved subcompositions and text-code modules.
 */
string VuoCompilerEnvironment::getOverriddenCompiledModuleCachePath(void)
{
	return overriddenCompiledModuleCachePath;
}

/**
 * Adds a source file to this environment even though it's located outside of this environment's module search paths.
 *
 * The source file is not watched for changes.
 */
void VuoCompilerEnvironment::addExpatriateSourceFile(const string &sourcePath)
{
	expatriateSourceFiles.push_back(sourcePath);

	if (find(moduleSearchPaths.begin(), moduleSearchPaths.end(), "") == moduleSearchPaths.end())
		moduleSearchPaths.push_back("");

	auto iter = sourceFilesAtSearchPath.find("");
	if (iter != sourceFilesAtSearchPath.end())
		sourceFilesAtSearchPath.erase(iter);
}

/**
 * Removes the source file at @a sourcePath previously added by @ref addExpatriateSourceFile, if any.
 */
void VuoCompilerEnvironment::removeExpatriateSourceFile(const string &sourcePath)
{
	for (auto i = expatriateSourceFiles.begin(); i != expatriateSourceFiles.end(); ++i)
	{
		if (VuoFileUtilities::arePathsEqual(*i, sourcePath))
		{
			expatriateSourceFiles.erase(i);

			auto iter = sourceFilesAtSearchPath.find("");
			if (iter != sourceFilesAtSearchPath.end())
				sourceFilesAtSearchPath.erase(iter);

			break;
		}
	}
}

/**
 * Updates the list of all node classes, types, and library modules in the folder at @a path.
 *
 * The top level of the folder is searched for `.vuonode`, `.vuonode+`, `.bc`, and `.bc+` files.
 * A `.vuonode` file may be either a module or an archive containing modules.
 * In the latter case, the `.vuonode` archive's top level is searched.
 *
 * If @a path is the cached modules folder, any module files whose source files no longer
 * exist or whose source files are newer than the module file are deleted.
 */
void VuoCompilerEnvironment::updateModulesAtSearchPath(const string &path)
{
	if (moduleFilesAtSearchPath.find(path) != moduleFilesAtSearchPath.end())
		return;

	set<string> moduleExtensions;
	moduleExtensions.insert("vuonode");
	moduleExtensions.insert("vuonode+");
	moduleExtensions.insert("bc");
	moduleExtensions.insert("bc+");
	set<string> archiveExtensions;
	archiveExtensions.insert("vuonode");
	set<VuoFileUtilities::File *> moduleFiles = VuoFileUtilities::findFilesInDirectory(path, moduleExtensions, archiveExtensions);

	map<string, VuoModuleInfo *> fileForModuleKey;
	for (set<VuoFileUtilities::File *>::iterator i = moduleFiles.begin(); i != moduleFiles.end(); ++i)
	{
		VuoFileUtilities::File *moduleFile = *i;

		// Ignore macOS extended attribute storage (a.k.a. xattr, resource fork).
		if (VuoStringUtilities::beginsWith(moduleFile->basename(), "._"))
			continue;

		VuoModuleInfo *m = new VuoModuleInfo(this, path, moduleFile, false, false);
		fileForModuleKey[m->getModuleKey()] = m;
	}

	if ((! builtIn || ! VuoCompiler::vuoFrameworkInProgressPath.empty()) && VuoFileUtilities::arePathsEqual(path, getCompiledModuleCachePath()))
	{
		for (map<string, VuoModuleInfo *>::iterator i = fileForModuleKey.begin(); i != fileForModuleKey.end(); )
		{
			bool isModuleOutdated = false;
			string modulePath = i->second->getFile()->path();

			VuoModuleInfo *sourceInfo = listSourceFile(i->first);
			if (sourceInfo)
				isModuleOutdated = sourceInfo->isNewerThan(i->second);

			if (! isModuleOutdated)
			{
				string dependencyFilePath = modulePath + ".d";
				if (VuoFileUtilities::fileExists(dependencyFilePath))
				{
					try
					{
						double moduleLastModified = VuoFileUtilities::getFileLastModifiedInSeconds(modulePath);

						shared_ptr<VuoMakeDependencies> makeDependencies = VuoMakeDependencies::createFromFile(dependencyFilePath);
						for (const string &dependencyPath : makeDependencies->getDependencyPaths())
						{
							if (! VuoFileUtilities::fileExists(dependencyPath) ||
									VuoFileUtilities::getFileLastModifiedInSeconds(dependencyPath) > moduleLastModified)
							{
								isModuleOutdated = true;
								break;
							}
						}
					}
					catch (VuoException &e)
					{
						isModuleOutdated = true;
					}
				}
				else
				{
					isModuleOutdated = true;
				}
			}

			if (isModuleOutdated)
			{
				deleteFromCompiledModuleCache(modulePath);
				delete i->second;
				fileForModuleKey.erase(i++);
			}
			else
				i++;
		}
	}

	moduleFilesAtSearchPath[path] = fileForModuleKey;
}

/**
 * Adds a single module to the list of all node classes, types, and library modules in the folder at @a moduleSearchPath.
 */
void VuoCompilerEnvironment::updateModuleAtSearchPath(const string &moduleSearchPath, const string &moduleRelativePath)
{
	string dir, file, ext;
	VuoFileUtilities::splitPath(moduleRelativePath, dir, file, ext);

	set<string> moduleExtensions;
	moduleExtensions.insert(ext);
	set<string> archiveExtensions;
	archiveExtensions.insert("vuonode");

	set<VuoFileUtilities::File *> moduleFiles = VuoFileUtilities::findFilesInDirectory(moduleSearchPath, moduleExtensions, archiveExtensions);

	for (set<VuoFileUtilities::File *>::iterator i = moduleFiles.begin(); i != moduleFiles.end(); ++i)
	{
		VuoFileUtilities::File *moduleFile = *i;

		VuoModuleInfo *m = new VuoModuleInfo(this, moduleSearchPath, moduleFile, false, false);
		moduleFilesAtSearchPath[moduleSearchPath][m->getModuleKey()] = m;
	}
}

/**
 * Updates list of all compositions in the folder at @a path.
 *
 * The top level of the folder is searched for `.vuo`, `.fs`, and C/C++/Objective-C files.
 */
void VuoCompilerEnvironment::updateSourceFilesAtSearchPath(const string &path)
{
	map<string, map<string, VuoModuleInfo *> >::iterator sourceFilesIter = sourceFilesAtSearchPath.find(path);
	if (sourceFilesIter != sourceFilesAtSearchPath.end())
		return;

	set<VuoFileUtilities::File *> sourceFiles;
	if (! path.empty())
	{
		set<string> sourceExtensions;
		sourceExtensions.insert("vuo");
		sourceExtensions.insert("fs");
		auto cext = VuoFileUtilities::getCFamilySourceExtensions();
		sourceExtensions.insert(cext.begin(), cext.end());
		sourceFiles = VuoFileUtilities::findFilesInDirectory(path, sourceExtensions, set<string>());
	}
	else
	{
		for (const string &sourcePath : expatriateSourceFiles)
		{
			string dir, file, ext;
			VuoFileUtilities::splitPath(sourcePath, dir, file, ext);
			VuoFileUtilities::File *sourceFile = new VuoFileUtilities::File(dir, file + "." + ext);
			sourceFiles.insert(sourceFile);
		}
	}

	map<string, VuoModuleInfo *> fileForModuleKey;
	for (set<VuoFileUtilities::File *>::iterator i = sourceFiles.begin(); i != sourceFiles.end(); ++i)
	{
		VuoFileUtilities::File *sourceFile = *i;

		string dir, moduleKey, ext;
		VuoFileUtilities::splitPath(sourceFile->getRelativePath(), dir, moduleKey, ext);
		bool isSubcomposition = (ext == "vuo");

		// Ignore missing expatriateSourceFiles — they might have been deleted in the meantime.
		if (path.empty() && !sourceFile->exists())
			continue;

		VuoModuleInfo *m = new VuoModuleInfo(this, path, sourceFile, true, isSubcomposition);
		if (fileForModuleKey.find(m->getModuleKey()) != fileForModuleKey.end())
			VUserLog("Warning: Conflicting source files for module %s are installed at %s", m->getModuleKey().c_str(), path.c_str());
		fileForModuleKey[m->getModuleKey()] = m;

		if (isSubcomposition)
		{
			VuoDependencyGraphVertex *compositionVertex = VuoDependencyGraphVertex::vertexForDependency(moduleKey, compositionDependencyGraph);
			compositionDependencyGraph->addVertex(compositionVertex);

			compositionVertex->setEnvironment(this);

			set<string> dependencies = m->getContainedNodeClasses();
			for (set<string>::iterator j = dependencies.begin(); j != dependencies.end(); ++j)
			{
				VuoDependencyGraphVertex *dependencyVertex = VuoDependencyGraphVertex::vertexForDependency(*j, compositionDependencyGraph);
				compositionDependencyGraph->addEdge(compositionVertex, dependencyVertex);
			}
		}
	}

	sourceFilesAtSearchPath[path] = fileForModuleKey;
}

/**
 * For any modules in @a knownModuleKeys that have been loaded from a file with a mangled (shortened) name,
 * updates the list of modules at @a path to use the unmangled module key.
 */
void VuoCompilerEnvironment::unmangleModuleKeysAtSearchPath(const string &path, const set<string> &knownModuleKeys)
{
	auto moduleFilesIter = moduleFilesAtSearchPath.find(path);
	if (moduleFilesIter == moduleFilesAtSearchPath.end())
		return;

	for (const string &moduleKey : knownModuleKeys)
	{
		string fileName = VuoCompilerModule::getFileNameForModuleKey(moduleKey);
		string mangledModuleKey = VuoCompiler::getModuleKeyForPath(fileName);
		if (mangledModuleKey != moduleKey)
		{
			auto foundIter = moduleFilesIter->second.find(mangledModuleKey);
			if (foundIter != moduleFilesIter->second.end())
			{
				VuoModuleInfo *moduleInfo = foundIter->second;
				moduleInfo->setUnmangledModuleKey(moduleKey);
				moduleFilesIter->second[moduleKey] = moduleInfo;
				moduleFilesIter->second.erase(foundIter);
			}
		}
	}
}

/**
 * Returns info for the module if it's found in one of the VuoCompilerEnvironment#moduleSearchPaths, otherwise null.
 *
 * If the module exists in both the cached compiled modules and the overridden cached compiled modules, returns the overridden version.
 */
VuoModuleInfo * VuoCompilerEnvironment::listModule(const string &moduleKey)
{
	vector<VuoModuleInfo *> foundModuleInfos;
	VuoModuleInfoIterator moduleIter = listModules({moduleKey});
	VuoModuleInfo *moduleInfo;
	while ((moduleInfo = moduleIter.next()))
		foundModuleInfos.push_back(moduleInfo);

	if (foundModuleInfos.size() > 1)
		for (VuoModuleInfo *moduleInfo : foundModuleInfos)
			if (VuoFileUtilities::arePathsEqual(getOverriddenCompiledModuleCachePath(), moduleInfo->getSearchPath()))
				return moduleInfo;

	if (foundModuleInfos.size() > 0)
		return foundModuleInfos.front();

	return nullptr;
}

/**
 * Returns info for each of the modules specified by @a moduleKeys that is found in one of the VuoCompilerEnvironment#moduleSearchPaths.
 */
VuoModuleInfoIterator VuoCompilerEnvironment::listModules(const set<string> &moduleKeys)
{
	for (const string &path : moduleSearchPaths)
	{
		updateModulesAtSearchPath(path);
		unmangleModuleKeysAtSearchPath(path, moduleKeys);
	}

	return VuoModuleInfoIterator(&moduleFilesAtSearchPath, getOverriddenCompiledModuleCachePath(), moduleKeys);
}

/**
 * Returns info for all of the modules found in the VuoCompilerEnvironment::moduleSearchPaths.
 */
VuoModuleInfoIterator VuoCompilerEnvironment::listAllModules(void)
{
	for (const string &path : moduleSearchPaths)
		updateModulesAtSearchPath(path);

	return VuoModuleInfoIterator(&moduleFilesAtSearchPath, getOverriddenCompiledModuleCachePath());
}

/**
 * Returns info for the module source file if it's found in one of the VuoCompilerEnvironment::moduleSearchPaths, otherwise null.
 */
VuoModuleInfo * VuoCompilerEnvironment::listSourceFile(const string &moduleKey)
{
	for (const auto &sourceFiles : sourceFilesAtSearchPath)
	{
		map<string, VuoModuleInfo *>::const_iterator foundIter = sourceFiles.second.find(moduleKey);
		if (foundIter != sourceFiles.second.end())
			return foundIter->second;
	}

	return NULL;
}

/**
 * Returns info for each of the module source files specified by @a moduleKeys that is found in one of the VuoCompilerEnvironment::moduleSearchPaths.
 */
VuoModuleInfoIterator VuoCompilerEnvironment::listSourceFiles(const set<string> &moduleKeys)
{
	for (const string &path : moduleSearchPaths)
		updateSourceFilesAtSearchPath(path);

	return VuoModuleInfoIterator(&sourceFilesAtSearchPath, "", moduleKeys);
}

/**
 * Returns info for all of the module source files found in the VuoCompilerEnvironment::moduleSearchPaths.
 */
VuoModuleInfoIterator VuoCompilerEnvironment::listAllSourceFiles(void)
{
	for (const string &path : moduleSearchPaths)
		updateSourceFilesAtSearchPath(path);

	return VuoModuleInfoIterator(&sourceFilesAtSearchPath, "");
}

/**
 * Returns the search paths for built-in node classes, types, and library modules.
 */
vector<string> VuoCompilerEnvironment::getBuiltInModuleSearchPaths(void)
{
	vector<string> builtInModuleSearchPaths;

	string vuoFrameworkPath = VuoCompiler::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInModuleSearchPaths.push_back(vuoFrameworkPath + "/Modules");
	}
	else
	{
		builtInModuleSearchPaths.push_back(VUO_BUILD_DIR "/library");
		builtInModuleSearchPaths.push_back(VUO_BUILD_DIR "/node");
		builtInModuleSearchPaths.push_back(VUO_BUILD_DIR "/type");
	}

	return builtInModuleSearchPaths;
}

/**
 * Returns the search paths for built-in libraries (other than library modules).
 */
vector<string> VuoCompilerEnvironment::getBuiltInLibrarySearchPaths(void)
{
	vector<string> builtInLibrarySearchPaths;

	string vuoFrameworkPath = VuoCompiler::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInLibrarySearchPaths.push_back(vuoFrameworkPath + "/Modules");

		// Ensure we (statically) link to our OpenSSL build when generating Vuo.framework's built-in module cache.
		builtInLibrarySearchPaths.push_back(OPENSSL_ROOT "/lib");
	}
	else
	{
		builtInLibrarySearchPaths.push_back(VUO_BUILD_DIR "/library");
		builtInLibrarySearchPaths.push_back(VUO_BUILD_DIR "/node");
		builtInLibrarySearchPaths.push_back(VUO_BUILD_DIR "/type");
		builtInLibrarySearchPaths.push_back(VUO_BUILD_DIR "/runtime");

		vector<string> conanLibDirs = VuoStringUtilities::split(CONAN_LIBRARY_PATHS, ';');
		builtInLibrarySearchPaths.insert(builtInLibrarySearchPaths.end(), conanLibDirs.begin(), conanLibDirs.end());
	}

	return builtInLibrarySearchPaths;
}

/**
 * Returns the search paths for built-in frameworks.
 */
vector<string> VuoCompilerEnvironment::getBuiltInFrameworkSearchPaths(void)
{
	vector<string> builtInFrameworkSearchPaths;

	string vuoFrameworkPath = VuoCompiler::getVuoFrameworkPath();
	if (! vuoFrameworkPath.empty())
	{
		builtInFrameworkSearchPaths.push_back(vuoFrameworkPath + "/Modules/");
		builtInFrameworkSearchPaths.push_back(vuoFrameworkPath + "/Frameworks/");
	}

	return builtInFrameworkSearchPaths;
}

/**
 * Starts surveilling the given directory for changes to the files within it, and
 * when they do change, loads/unloads the modules for those files.
 */
void VuoCompilerEnvironment::startWatchingModuleSearchPath(const string &moduleSearchPath)
{
	VuoFileWatcher *watcher = new VuoFileWatcher(this, moduleSearchPath);
	moduleSearchPathWatchers.insert(watcher);
}

/**
 * Stops watching all watched directories.
 */
void VuoCompilerEnvironment::stopWatchingModuleSearchPaths(void)
{
	for (set<VuoFileWatcher *>::iterator i = moduleSearchPathWatchers.begin(); i != moduleSearchPathWatchers.end(); ++i)
		delete *i;

	moduleSearchPathWatchers.clear();
}

/**
 * VuoFileWatcher delegate function, called when one or more files in @a moduleSearchPath
 * have been added, modified, or removed.
 *
 * @threadNoQueue{VuoCompiler::environmentQueue}
 * @threadNoQueue{moduleSearchPathContentsChangedQueue}
 */
void VuoCompilerEnvironment::fileChanged(const string &moduleSearchPath)
{
	dispatch_sync(moduleSearchPathContentsChangedQueue, ^{
					  moduleSearchPathContentsChanged(moduleSearchPath);
				  });
}

/**
 * Callback for when files have been added, modified, or removed from one of the module search paths.
 * Updates the records of known module and composition files, unloads and loads compiled modules,
 * schedules module source files to be compiled, and notifies each of VuoCompilerEnvironment#compilersToNotify.
 *
 * @threadNoQueue{VuoCompiler::environmentQueue}
 * @threadQueue{moduleSearchPathContentsChangedQueue}
 */
void VuoCompilerEnvironment::moduleSearchPathContentsChanged(const string &moduleSearchPath)
{
	//VLog("                 E=%p -- %s", this, moduleSearchPath.c_str());
	VuoCompiler *compilerForLoading = new VuoCompiler(moduleSearchPath + "/unused");

	__block set<string> modulesAdded;
	__block set<string> modulesModifed;
	__block set<string> modulesRemoved;
	__block set<string> compositionsAdded;
	__block set<string> compositionsModifed;
	__block set<string> compositionsRemoved;

	dispatch_sync(VuoCompiler::environmentQueue, ^{

					  // Remove the old file records from the environment.

					  map<string, VuoModuleInfo *> oldModules;
					  map<string, VuoModuleInfo *> oldCompositions;

					  map<string, map<string, VuoModuleInfo *> >::iterator mf = moduleFilesAtSearchPath.find(moduleSearchPath);
					  if (mf != moduleFilesAtSearchPath.end())
					  {
						  for (map<string, VuoModuleInfo *>::iterator j = mf->second.begin(); j != mf->second.end(); ++j)
						  {
							  oldModules[j->first] = j->second;
						  }

						  moduleFilesAtSearchPath.erase(mf);
					  }

					  map<string, map<string, VuoModuleInfo *> >::iterator cf = sourceFilesAtSearchPath.find(moduleSearchPath);
					  if (cf != sourceFilesAtSearchPath.end())
					  {
						  for (map<string, VuoModuleInfo *>::iterator j = cf->second.begin(); j != cf->second.end(); ++j)
						  {
							  oldCompositions[j->first] = j->second;

							  VuoDirectedAcyclicGraph::Vertex *vertex = compositionDependencyGraph->findVertex(j->first);
							  compositionDependencyGraph->removeVertex(vertex);
						  }

						  sourceFilesAtSearchPath.erase(cf);
					  }

					  // Rebuild the file records based on the directory contents.

					  updateModulesAtSearchPath(moduleSearchPath);
					  updateSourceFilesAtSearchPath(moduleSearchPath);

					  set<string> oldModuleKeys;
					  for (auto o : oldModules)
						  if (! o.second->isModuleKeyMangled())
							  oldModuleKeys.insert(o.first);

					  unmangleModuleKeysAtSearchPath(moduleSearchPath, oldModuleKeys);

					  // Remove any overrides for source files that have been modified or removed.

					  auto omf = moduleFilesAtSearchPath.find(getOverriddenCompiledModuleCachePath());
					  if (omf != moduleFilesAtSearchPath.end())
					  {
						  for (auto oldComposition : oldCompositions)
						  {
							  for (auto i = omf->second.begin(); i != omf->second.end(); ++i)
							  {
								  if (i->first == oldComposition.first)
								  {
									  VuoFileUtilities::deleteFile(i->second->getFile()->path());
									  omf->second.erase(i);
									  break;
								  }
							  }
						  }
					  }

					  // Compare the old and new file records to see what has changed.

					  mf = moduleFilesAtSearchPath.find(moduleSearchPath);
					  if (mf != moduleFilesAtSearchPath.end())
					  {
						  for (map<string, VuoModuleInfo *>::iterator n = mf->second.begin(); n != mf->second.end(); ++n)
						  {
							  string moduleKey = n->first;

							  map<string, VuoModuleInfo *>::iterator o = oldModules.find(moduleKey);
							  if (o != oldModules.end())
							  {
								  if (n->second->isNewerThan(o->second))
								  {
									  modulesModifed.insert(moduleKey);
								  }
								  else
								  {
									  n->second->setAttempted(o->second->getAttempted());
								  }

								  delete o->second;
								  oldModules.erase(o);
							  }
							  else
							  {
								  modulesAdded.insert(moduleKey);
							  }
						  }
					  }

					  cf = sourceFilesAtSearchPath.find(moduleSearchPath);
					  if (cf != sourceFilesAtSearchPath.end())
					  {
						  for (map<string, VuoModuleInfo *>::iterator n = cf->second.begin(); n != cf->second.end(); ++n)
						  {
							  string moduleKey = n->first;

							  map<string, VuoModuleInfo *>::iterator o = oldCompositions.find(moduleKey);
							  if (o != oldCompositions.end())
							  {
								  if (n->second->isNewerThan(o->second))
								  {
									  compositionsModifed.insert(moduleKey);
								  }
								  else
								  {
									  n->second->setAttempted(o->second->getAttempted());
									  n->second->setSourceCode(o->second->getSourceCode());
								  }

								  delete o->second;
								  oldCompositions.erase(o);
							  }
							  else
							  {
								  compositionsAdded.insert(moduleKey);
							  }
						  }
					  }

					  for (map<string, VuoModuleInfo *>::iterator o = oldModules.begin(); o != oldModules.end(); ++o)
					  {
						  delete o->second;
						  modulesRemoved.insert(o->first);
					  }

					  for (map<string, VuoModuleInfo *>::iterator o = oldCompositions.begin(); o != oldCompositions.end(); ++o)
					  {
						  delete o->second;
						  compositionsRemoved.insert(o->first);
					  }

					  compilerForLoading->loadModulesAndSources(modulesAdded, modulesModifed, modulesRemoved,
																compositionsAdded, compositionsModifed, compositionsRemoved,
																false, false, this, nullptr, nullptr, "");
				  });

	delete compilerForLoading;
}

/**
 * Callback for when a single file has been added, modified, or removed from one of the module search paths.
 *
 * Unlike @ref VuoCompilerEnvironment::moduleSearchPathContentsChanged, this function only updates the
 * record for the one file. It does not check for other changed files in the directory.
 *
 * @threadNoQueue{VuoCompiler::environmentQueue}
 */
void VuoCompilerEnvironment::moduleFileChanged(const string &moduleKey, const string &modulePath, const string &moduleSourceCode,
											   std::function<void(void)> moduleLoadedCallback,
											   VuoCompiler *compiler, VuoCompilerIssues *issues)
{
	//VLog("                 E=%p -- %s", this, modulePath.c_str());
	dispatch_sync(VuoCompiler::environmentQueue, ^{

					  string moduleDir, file, ext;
					  VuoFileUtilities::splitPath(modulePath, moduleDir, file, ext);
					  VuoFileUtilities::canonicalizePath(moduleDir);

					  unmangleModuleKeysAtSearchPath(moduleDir, {moduleKey});

					  // Remove the old file record from the environment.

					  bool foundOldModule = false;
					  auto moduleSearchPathIter = moduleFilesAtSearchPath.find(moduleDir);
					  if (moduleSearchPathIter != moduleFilesAtSearchPath.end())
					  {
						  auto moduleIter = moduleSearchPathIter->second.find(moduleKey);
						  if (moduleIter != moduleSearchPathIter->second.end())
						  {
							  delete moduleIter->second;
							  moduleSearchPathIter->second.erase(moduleIter);
							  foundOldModule = true;
						  }
					  }

					  // Update the file record for the module by re-checking the file.

					  updateModuleAtSearchPath(moduleDir, file + "." + ext);
					  unmangleModuleKeysAtSearchPath(moduleDir, {moduleKey});

					  // Compare the old and new file records to see how the module has changed.

					  bool foundNewModule = false;
					  moduleSearchPathIter = moduleFilesAtSearchPath.find(moduleDir);
					  if (moduleSearchPathIter != moduleFilesAtSearchPath.end())
					  {
						  auto moduleIter = moduleSearchPathIter->second.find(moduleKey);
						  if (moduleIter != moduleSearchPathIter->second.end())
						  {
							  foundNewModule = true;
						  }
					  }

					  set<string> modulesAdded;
					  set<string> modulesModified;
					  set<string> modulesRemoved;

					  if ((foundOldModule || VuoFileUtilities::arePathsEqual(moduleDir, getOverriddenCompiledModuleCachePath())) && foundNewModule)
					  {
						  modulesModified.insert(moduleKey);
					  }
					  else if (! foundOldModule && foundNewModule)
					  {
						  modulesAdded.insert(moduleKey);
					  }
					  else if (foundOldModule && ! foundNewModule)
					  {
						  modulesRemoved.insert(moduleKey);
					  }

					  compiler->loadModulesAndSources(modulesAdded, modulesModified, modulesRemoved,
													  set<string>(), set<string>(), set<string>(),
													  false, false, this, issues, moduleLoadedCallback, moduleSourceCode);
				  });

}

/**
 * Deletes the files and file record for @a moduleKey in the overridden compiled modules directory of the module cache.
 */
void VuoCompilerEnvironment::deleteOverriddenModuleFile(const string &moduleKey)
{
	string moduleCachePath = getOverriddenCompiledModuleCachePath();

	auto iter = moduleFilesAtSearchPath[moduleCachePath].find(moduleKey);
	if (iter != moduleFilesAtSearchPath[moduleCachePath].end())
	{
		deleteFromCompiledModuleCache(iter->second->getFile()->path());
		delete iter->second;
		moduleFilesAtSearchPath[moduleCachePath].erase(iter);
	}
}

/**
 * Notifies each of VuoCompilerEnvironment#compilersToNotify of modules loaded/unloaded and issues encountered.
 */
void VuoCompilerEnvironment::notifyCompilers(const set<VuoCompilerModule *> &modulesAdded,
											 const set< pair<VuoCompilerModule *, VuoCompilerModule *> > &modulesModified,
											 const set<VuoCompilerModule *> &modulesRemoved, VuoCompilerIssues *issues,
											 bool oldModulesInvalidated)
{
	if (! (modulesAdded.empty() && modulesModified.empty() && modulesRemoved.empty() && issues->isEmpty()) )
	{
		set< pair<VuoCompilerModule *, VuoCompilerModule *> > invalidatedModulesModified;
		set<VuoCompilerModule *> invalidatedModulesRemoved;
		if (oldModulesInvalidated)
		{
			invalidatedModulesModified = modulesModified;
			invalidatedModulesRemoved = modulesRemoved;
		}

		VuoCompilerDelegate::LoadedModulesData *delegateData = new VuoCompilerDelegate::LoadedModulesData(invalidatedModulesModified, invalidatedModulesRemoved, issues);

		map<string, VuoCompilerModule *> modulesAddedMap;
		map<string, pair<VuoCompilerModule *, VuoCompilerModule *> > modulesModifiedMap;
		map<string, VuoCompilerModule *> modulesRemovedMap;
		for (VuoCompilerModule *m : modulesAdded)
			modulesAddedMap[m->getPseudoBase()->getModuleKey()] = m;
		for (pair<VuoCompilerModule *, VuoCompilerModule *> m : modulesModified)
			modulesModifiedMap[m.first->getPseudoBase()->getModuleKey()] = m;
		for (VuoCompilerModule *m : modulesRemoved)
			modulesRemovedMap[m->getPseudoBase()->getModuleKey()] = m;

		dispatch_sync(compilersToNotifyQueue, ^{
						  for (set<VuoCompiler *>::iterator i = compilersToNotify.begin(); i != compilersToNotify.end(); ++i) {
							  delegateData->retain();
						  }
						  for (set<VuoCompiler *>::iterator i = compilersToNotify.begin(); i != compilersToNotify.end(); ++i) {
							  (*i)->loadedModules(modulesAddedMap, modulesModifiedMap, modulesRemovedMap, issues, delegateData, this);
						  }
					  });
	}
	else
	{
		delete issues;
	}
}

/**
 * Loads each of @a moduleKeys that is an already-compiled module file or in-memory module,
 * belongs to this environment, and is not already loaded.
 *
 * Returns the modules that were actually loaded.
 *
 * Issues are logged to the console.
 */
set<VuoCompilerModule *> VuoCompilerEnvironment::loadCompiledModules(const set<string> &moduleKeys, const map<string, string> &sourceCodeForModule,
																	 dispatch_queue_t llvmQueue)
{
	set<VuoCompilerModule *> modulesLoaded;

	// Add the pending in-memory module, if any, to the list.

	string inMemoryModuleKey;
	if (inMemoryModuleAwaitingLoad)
	{
		inMemoryModuleKey = inMemoryModuleAwaitingLoad->getPseudoBase()->getModuleKey();
		if (moduleKeys.find(inMemoryModuleKey) != moduleKeys.end())
			modulesLoaded.insert(inMemoryModuleAwaitingLoad);
	}

	// Read the rest of the modules from file and add them to the list.

	VuoModuleInfoIterator modulesToLoadIter = listModules(moduleKeys);
	VuoModuleInfo *moduleInfo;
	while ((moduleInfo = modulesToLoadIter.next()))
	{
		string moduleKey = moduleInfo->getModuleKey();

		// Skip the module if its file is not in this environment, if the module has already been loaded,
		// or if the compiler previously tried to load the module and it failed.
		if (moduleInfo->getEnvironment() != this || moduleKey == inMemoryModuleKey || findModule(moduleKey) || moduleInfo->getAttempted())
			continue;

		moduleInfo->setAttempted(true);

		VuoCompilerModule *module = readModuleFromFile(moduleInfo, llvmQueue);

		if (module)
			modulesLoaded.insert(module);
	}

	// Add each listed module to this environment.

	for (VuoCompilerModule *module : modulesLoaded)
	{
		string moduleKey = module->getPseudoBase()->getModuleKey();

		if (dynamic_cast<VuoCompilerNodeClass *>(module))
			nodeClasses[moduleKey] = static_cast<VuoCompilerNodeClass *>(module);
		else if (dynamic_cast<VuoCompilerType *>(module))
			types[moduleKey] = static_cast<VuoCompilerType *>(module);
		else
			libraryModules[moduleKey] = module;

		module->setBuiltIn( isBuiltIn() );

		VuoModuleInfo *moduleInfo = listModule(moduleKey);
		if (moduleInfo)
		{
			VuoNodeSet *nodeSet = VuoNodeSet::createNodeSetForModule(moduleInfo->getFile());
			if (nodeSet)
			{
				map<string, VuoNodeSet *>::iterator nodeSetIter = nodeSetForName.find(nodeSet->getName());
				if (nodeSetIter == nodeSetForName.end())
				{
					nodeSetForName[nodeSet->getName()] = nodeSet;
				}
				else
				{
					delete nodeSet;
					nodeSet = nodeSetIter->second;
				}
				module->getPseudoBase()->setNodeSet(nodeSet);
			}
		}

		// If the module has an accompanying source file -- i.e., the module was compiled from a composition or text code,
		// or it's a generic module not in a node set -- store the source code in the VuoCompilerModule.
		VuoModuleInfo *sourceInfo = listSourceFile(moduleKey);
		if (sourceInfo)
		{
			module->setSourcePath( sourceInfo->getFile()->path() );

			auto sourceCodeIter = sourceCodeForModule.find(moduleKey);
			if (sourceCodeIter != sourceCodeForModule.end())
				module->setSourceCode( sourceCodeIter->second );
			else
				module->setSourceCode( sourceInfo->getFile()->getContentsAsString() );
		}

		addToDependencyGraph(module);
		modulesChanged();
	}

	return modulesLoaded;
}

/**
 * Starts generating and loading each of @a moduleKeys that is a specialization of a generic node class
 * and hasn't already been attempted to be loaded.
 *
 * Loading is scheduled asynchronously. The caller can wait on the returned dispatch groups,
 * and is responsible for releasing them.
 *
 * Assumes that the dependencies of each specialized node class have already been loaded.
 */
set<dispatch_group_t> VuoCompilerEnvironment::generateSpecializedModules(const set<string> &moduleKeys, VuoCompiler *compiler,
																		 dispatch_group_t moduleSourceCompilersExist, dispatch_queue_t llvmQueue)
{
	set<dispatch_group_t > loadingGroups;

	for (string moduleKey : moduleKeys)
	{
		// Skip the module if it's definitely not a node class or type.

		if (! VuoNodeClass::isNodeClassName(moduleKey) && ! VuoType::isTypeName(moduleKey))
			continue;

		// Skip the module if it's in the process of being loaded, but have the caller wait for it to finish loading.

		map<string, dispatch_group_t>::iterator iter = specializedModulesLoading.find(moduleKey);
		if (iter != specializedModulesLoading.end())
		{
			loadingGroups.insert(iter->second);
			dispatch_retain(iter->second);
			continue;
		}

		dispatch_group_t loadingGroup = dispatch_group_create();
		dispatch_group_enter(loadingGroup);
		specializedModulesLoading[moduleKey] = loadingGroup;
		loadingGroups.insert(loadingGroup);

		dispatch_group_enter(moduleSourceCompilersExist);
		dispatch_group_enter(VuoCompiler::moduleSourceCompilersExistGlobally);

		// Generate the module.
		// This is done asynchronously since VuoCompilerSpecializedNodeClass and VuoCompilerCompoundType need to use environmentQueue.

		dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
		dispatch_async(queue, ^{

			auto moduleLoadedCallback = [=](){
				specializedModulesLoading.erase(moduleKey);
				dispatch_group_leave(loadingGroup);
			};

			VuoCompilerModule *module = nullptr;
			VuoCompilerIssues *issues = new VuoCompilerIssues;

			try
			{
				if (VuoNodeClass::isNodeClassName(moduleKey))
				{
					VuoNodeClass *baseNodeClass = VuoCompilerSpecializedNodeClass::newNodeClass(moduleKey, compiler, llvmQueue);
					if (baseNodeClass)
						module = baseNodeClass->getCompiler();
				}
				else
				{
					module = VuoCompilerCompoundType::newType(moduleKey, compiler, llvmQueue);
				}
			}
			catch (VuoCompilerException &e)
			{
				issues->append(e.getIssues());
			}

			if (! module)
			{
				if (issues->hasErrors())
					notifyCompilers(set<VuoCompilerModule *>(), set< pair<VuoCompilerModule *, VuoCompilerModule *> >(), set<VuoCompilerModule *>(), issues, false);

				dispatch_sync(VuoCompiler::environmentQueue, ^{
					moduleLoadedCallback();
				});
			}
			else if (! module->getModule())
			{
				// The module is a not-fully-specialized generic node class — which can't be cached since the node class name
				// alone doesn't uniquely specify it (the backing types may differ between compositions).
				// Add the in-memory node class to the environment.

				dispatch_sync(VuoCompiler::environmentQueue, ^{
					loadInMemoryModule(module, "", moduleLoadedCallback, compiler, llvmQueue);
				});
			}
			else
			{
				bool moduleVerified = false;
				try
				{
					VuoCompiler::verifyModule(module->getModule(), issues);
					moduleVerified = true;
				}
				catch (VuoCompilerException &e)
				{
					VuoCompiler::destroyModule(module);

					notifyCompilers(set<VuoCompilerModule *>(), set< pair<VuoCompilerModule *, VuoCompilerModule *> >(), set<VuoCompilerModule *>(), issues, false);

					dispatch_sync(VuoCompiler::environmentQueue, ^{
						moduleLoadedCallback();
					});
				}

				if (moduleVerified)
				{
					// The module is a fully-specialized generic module.
					// Save the module to a file in the cache, then notify the environment to load the module from the cache.

					string compiledModulePath = getCompiledModuleCachePath() + "/" + module->getFileName();
					bool moduleWritten = writeToCompiledModuleCache(module->getModule(), compiledModulePath, module->getMakeDependencies(), llvmQueue, issues);

					if (moduleWritten)
					{
						VuoCompiler::destroyModule(module);

						moduleFileChanged(moduleKey, compiledModulePath, "", moduleLoadedCallback, compiler, issues);
					}
					else
					{
						// If saving to the cache fails, fall back to loading the in-memory module.

						if (! issues->isEmpty())
							VUserLog("%s", issues->getLongDescription(false).c_str());

						dispatch_sync(VuoCompiler::environmentQueue, ^{
							loadInMemoryModule(module, "", moduleLoadedCallback, compiler, llvmQueue);
						});
					}
				}
			}

			dispatch_group_leave(moduleSourceCompilersExist);
			dispatch_group_leave(VuoCompiler::moduleSourceCompilersExistGlobally);
		});
	}

	return loadingGroups;
}

/**
 * Starts compiling each of @a moduleKeys that is a composition or ISF file, belongs to this environment,
 * doesn't have a compiled file or has a compiled file older than the source file, and
 * hasn't already been attempted to be compiled.
 *
 * Compiling is scheduled asynchronously. The caller can wait on the returned dispatch groups.
 *
 * If a subcomposition to be compiled has other subcompositions as dependencies, the dependencies
 * are compiled first.
 */
set<dispatch_group_t> VuoCompilerEnvironment::compileModulesFromSourceCode(const set<string> &moduleKeys, bool shouldRecompileIfUnchanged,
																		   dispatch_group_t moduleSourceCompilersExist, dispatch_queue_t llvmQueue)
{
	VuoModuleInfoIterator modulesToLoadIter = listSourceFiles(moduleKeys);

	int environmentIndex = VuoCompiler::sharedEnvironments[target].size();
	for (int i = 0; i < VuoCompiler::sharedEnvironments[target].size(); ++i)
		if (this == VuoCompiler::sharedEnvironments[target].at(i).at(0))
			environmentIndex = i;

	set<dispatch_group_t> sourcesLoading;
	int sourcesEnqueued = 0;
	VuoModuleInfo *sourceInfo;
	while ((sourceInfo = modulesToLoadIter.next()))
	{
		string moduleKey = sourceInfo->getModuleKey();

		dispatch_group_t loadingGroup = sourceInfo->getLoadingGroup();
		sourcesLoading.insert(loadingGroup);

		// Skip compiling if the source file has already been scheduled for compilation.
		// Either its compilation is in progress or it failed to compile.

		if (sourceInfo->getAttempted())
			continue;

		// Skip compiling if the compiled module is up-to-date.

		string sourceCode = sourceInfo->getSourceCode();

		if (! shouldRecompileIfUnchanged)
		{
			VuoCompilerNodeClass *existingNodeClass = getNodeClass(moduleKey);
			if (existingNodeClass && existingNodeClass->getSourceCode() == sourceCode)
				continue;
		}

		// Enqueue the source file to be compiled.

		sourceInfo->setAttempted(true);

		dispatch_group_enter(loadingGroup);
		dispatch_group_enter(moduleSourceCompilersExist);
		dispatch_group_enter(VuoCompiler::moduleSourceCompilersExistGlobally);

		VuoModuleCompilationQueue::Item *queueItem = new VuoModuleCompilationQueue::Item();
		queueItem->moduleKey = moduleKey;
		queueItem->sourcePath = sourceInfo->getFile()->path();
		queueItem->sourceCode = sourceCode;
		queueItem->sourceFile = sourceInfo->getFile();
		queueItem->cachedModulesPath = sourceInfo->isSourceCodeOverridden() ? getOverriddenCompiledModuleCachePath() : getCompiledModuleCachePath();
		queueItem->compiledModulePath = queueItem->cachedModulesPath + "/" + moduleKey + ".vuonode";
		queueItem->loadingGroup = loadingGroup;
		queueItem->priority = { environmentIndex, sourceInfo->getLongestDownstreamPath() };
		moduleCompilationQueue->enqueue(queueItem);
		++sourcesEnqueued;
	}

	// Compile each enqueued source file. This is done asynchronously for several reasons:
	//   - To avoid environmentQueue calling compiler code calling environmentQueue.
	//   - To compile dependencies that were enqueued later while a compilation that was enqueued earlier waits.
	//   - To be more efficient when compiling multiple source files.

	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
	dispatch_async(queue, ^{
		for (int i = 0; i < sourcesEnqueued; ++i)
		{
			__block VuoModuleCompilationQueue::Item *queueItem = moduleCompilationQueue->next();
			VDebugLog("Compiling %s", queueItem->moduleKey.c_str());

			dispatch_async(queue, ^{
				VuoCompiler *compiler = new VuoCompiler(queueItem->sourcePath, target);
				compiler->setLoadAllModules(false);

				VuoModuleCompilationQueue::Item *queueItemForCallback = queueItem;
				auto moduleLoadedCallback = [=](){
					dispatch_group_leave(queueItemForCallback->loadingGroup);
					moduleCompilationQueue->completed(queueItemForCallback);
				};

				VuoModuleCompiler *moduleCompiler = compiler->createModuleCompiler(queueItem->moduleKey, queueItem->sourcePath);
				if (moduleCompiler)
				{
					moduleCompiler->overrideSourceCode(queueItem->sourceCode, queueItem->sourcePath);

					VuoCompilerIssues *issues = new VuoCompilerIssues;
					VuoModuleCompilerResults results = moduleCompiler->compile(llvmQueue, issues);
					Module *module = results.module;

					bool moduleVerified = false;
					if (module)
					{
						try
						{
							VuoCompiler::verifyModule(module, issues);
							moduleVerified = true;
						}
						catch (VuoCompilerException &e) {}
					}

					bool moduleWritten = false;
					if (moduleVerified)
						moduleWritten = writeToCompiledModuleCache(module, queueItem->compiledModulePath, results.makeDependencies, llvmQueue, issues);

					issues->setFilePathIfEmpty(queueItem->sourcePath);

					if (! module || ! moduleVerified || moduleWritten)
					{
						moduleFileChanged(queueItem->moduleKey, queueItem->compiledModulePath, queueItem->sourceCode, moduleLoadedCallback, compiler, issues);
					}
					else
					{
						if (! issues->isEmpty())
							VUserLog("%s", issues->getLongDescription(false).c_str());

						dispatch_sync(VuoCompiler::environmentQueue, ^{
							loadInMemoryModule(queueItem->moduleKey, queueItem->sourceCode, module, moduleLoadedCallback, compiler, llvmQueue);
						});
					}
				}
				else
				{
					VuoCompilerIssues *issues = new VuoCompilerIssues;

					VuoCompilerComposition *composition = nullptr;
					Module *module = nullptr;
					bool moduleVerified = false;
					bool moduleWritten = false;
					try
					{
						composition = VuoCompilerComposition::newCompositionFromGraphvizDeclaration(queueItem->sourceCode, compiler);

						module = compiler->compileCompositionToModule(composition, queueItem->moduleKey, false, issues);
						if (! module)
							throw VuoCompilerException(issues, false);

						VuoCompiler::verifyModule(module, issues);
						moduleVerified = true;

						shared_ptr<VuoMakeDependencies> makeDependencies = VuoMakeDependencies::createFromComponents(queueItem->compiledModulePath, {queueItem->sourcePath});

						moduleWritten = writeToCompiledModuleCache(module, queueItem->compiledModulePath, makeDependencies, llvmQueue, issues);
					}
					catch (VuoCompilerException &e)
					{
						if (issues != e.getIssues())
							issues->append(e.getIssues());
					}

					if (composition)
					{
						if (moduleVerified && ! moduleWritten)
							composition->takeModule();

						VuoComposition *baseComposition = composition->getBase();
						delete composition;
						delete baseComposition;
					}

					issues->setFilePathIfEmpty(queueItem->sourcePath);

					if (! module || ! moduleVerified || moduleWritten)
					{
						moduleFileChanged(queueItem->moduleKey, queueItem->compiledModulePath, queueItem->sourceCode, moduleLoadedCallback, compiler, issues);
					}
					else
					{
						if (! issues->isEmpty())
							VUserLog("%s", issues->getLongDescription(false).c_str());

						dispatch_sync(VuoCompiler::environmentQueue, ^{
							loadInMemoryModule(queueItem->moduleKey, queueItem->sourceCode, module, moduleLoadedCallback, compiler, llvmQueue);
						});
					}
				}

				delete moduleCompiler;
				delete compiler;
				dispatch_group_leave(moduleSourceCompilersExist);
				dispatch_group_leave(VuoCompiler::moduleSourceCompilersExistGlobally);
			});
		}
	});

	return sourcesLoading;
}

/**
 * Unloads each of @a moduleKeys that is a module loaded in this environment.
 *
 * Returns the modules that were actually unloaded.
 * The caller is responsible for deallocating them with VuoCompiler::destroyModule().
 */
set<VuoCompilerModule *> VuoCompilerEnvironment::unloadCompiledModules(const set<string> &moduleKeys)
{
	set<VuoCompilerModule *> modulesUnloaded;

	for (set<string>::const_iterator i = moduleKeys.begin(); i != moduleKeys.end(); ++i)
	{
		string moduleKey = *i;
		VuoCompilerModule *module = NULL;

		map<string, VuoCompilerNodeClass *>::iterator nodeClassIter = nodeClasses.find(moduleKey);
		if (nodeClassIter != nodeClasses.end())
		{
			module = nodeClassIter->second;
			nodeClasses.erase(nodeClassIter);
		}
		else
		{
			map<string, VuoCompilerType *>::iterator typeIter = types.find(moduleKey);
			if (typeIter != types.end())
			{
				module = typeIter->second;
				types.erase(typeIter);
			}
			else
			{
				map<string, VuoCompilerModule *>::iterator libraryModuleIter = libraryModules.find(moduleKey);
				if (libraryModuleIter != libraryModules.end())
				{
					module = libraryModuleIter->second;
					libraryModules.erase(libraryModuleIter);
				}
			}
		}

		if (module)
		{
			modulesUnloaded.insert(module);
			removeFromDependencyGraph(module);
			modulesChanged();
		}
	}

	return modulesUnloaded;
}

/**
 * Attempts to write the LLVM module to a bitcode file in the compiled modules directories in the module cache.
 *
 * @param module The module to write.
 * @param compiledModulePath The file to write the module to.
 * @param makeDependencies The contents of the dependency (.d) file to create in the same directory as the module.
 * @param llvmQueue The dispatch queue to use when writing the module.
 * @param issues If the module fails to be written for a reason other than the module cache being unavailable
 *   (either this environment not having a module cache or the module cache being used by another process),
 *   a warning is appended to this object.
 * @return True if the module was written successfully, false otherwise.
 *
 */
bool VuoCompilerEnvironment::writeToCompiledModuleCache(Module *module, const string &compiledModulePath, shared_ptr<VuoMakeDependencies> makeDependencies,
														dispatch_queue_t llvmQueue, VuoCompilerIssues *issues)
{
	string compiledModuleDir, file, ext;
	VuoFileUtilities::splitPath(compiledModulePath, compiledModuleDir, file, ext);

	auto writeModule = [=]()
	{
		try
		{
			VuoFileUtilities::makeDir(compiledModuleDir);

			__block bool wroteModule = false;
			dispatch_sync(llvmQueue, ^{
				VuoCompilerIssues writeIssues;
				try
				{
					VuoCompiler::writeModuleToBitcode(module, target, compiledModulePath, &writeIssues);
					wroteModule = true;
				}
				catch (VuoCompilerException &e)
				{
					for (VuoCompilerIssue issue : writeIssues.getList())
					{
						VuoCompilerIssue newIssue(VuoCompilerIssue::Warning, "compiling module", issue.getFilePath(), issue.getSummary(), issue.getDetails(false));
						issues->append(newIssue);
					}
				}
			});

			if (wroteModule && makeDependencies)
			{
				makeDependencies->setCompiledFilePath(compiledModulePath);
				makeDependencies->writeToFile(compiledModulePath + ".d");
			}

			return wroteModule;
		}
		catch (VuoException &e)
		{
			VuoCompilerIssue issue(VuoCompilerIssue::Warning, "compiling module", compiledModulePath, "", e.what());
			issues->append(issue);

			return false;
		}
	};

	if (VuoFileUtilities::arePathsEqual(compiledModuleDir, getOverriddenCompiledModuleCachePath()))
		return writeModule();
	else if (moduleCache)
		return moduleCache->modifyCompiledModules(writeModule);
	else
		return false;
}

/**
 * Attempts to delete a bitcode file and its dependency file from the compiled modules directory in the module cache.
 *
 * Silently fails if the files could not be deleted because the module cache is unavailable.
 */
void VuoCompilerEnvironment::deleteFromCompiledModuleCache(const string &compiledModulePath)
{
	auto deleteModule = [=]()
	{
		VuoFileUtilities::deleteFile(compiledModulePath);
		VuoFileUtilities::deleteFile(compiledModulePath + ".d");
		return true;
	};

	string compiledModuleDir, file, ext;
	VuoFileUtilities::splitPath(compiledModulePath, compiledModuleDir, file, ext);

	if (VuoFileUtilities::arePathsEqual(compiledModuleDir, getOverriddenCompiledModuleCachePath()))
		deleteModule();
	else if (moduleCache)
		moduleCache->modifyCompiledModules(deleteModule);
}

/**
 * Attempts to delete the bitcode file and dependency file for each of @a moduleKeys from the compiled modules directory
 * in the module cache.
 *
 * Silently fails if the files could not be deleted because the module cache is unavailable.
 */
void VuoCompilerEnvironment::deleteFromCompiledModuleCache(const set<string> &moduleKeys)
{
	for (const string &moduleKey : moduleKeys)
	{
		string moduleCachePath = getCompiledModuleCachePath();

		auto iter = moduleFilesAtSearchPath[moduleCachePath].find(moduleKey);
		if (iter != moduleFilesAtSearchPath[moduleCachePath].end())
			deleteFromCompiledModuleCache(iter->second->getFile()->path());
	}
}

/**
 * Attempts to read a node class, type, or library module from the file described by @a moduleInfo.
 *
 * Returns the module on success, null on failure.
 */
VuoCompilerModule * VuoCompilerEnvironment::readModuleFromFile(VuoModuleInfo *moduleInfo, dispatch_queue_t llvmQueue)
{
	string moduleKey = moduleInfo->getModuleKey();

	// Skip certain LLVM modules that definitely aren't Vuo modules to avoid adding struct types defined in them to the LLVM
	// context, resulting in mismatched struct types in code generation (e.g. %struct.NodeContext and %struct.NodeContext.1).
	if (VuoStringUtilities::beginsWith(moduleKey, "libVuo"))
		return NULL;

	// Don't try to load single-target parts
	// (such as those found in `build/test/TestControlAndTelemetry`),
	// since they just fail and pollute the logs.
	if (VuoStringUtilities::endsWith(moduleKey, "-x86_64")
	 || VuoStringUtilities::endsWith(moduleKey, "-arm64"))
		return nullptr;

	__block size_t inputDataBytes;
	__block char *rawInputData;
	dispatch_sync(llvmQueue, ^{
		try
		{
			rawInputData = moduleInfo->getFile()->getContentsAsRawData(inputDataBytes);
		}
		catch (VuoException &e)
		{
			rawInputData = NULL;
			VUserLog("Warning: Couldn't load module '%s'. Its file may have been deleted. (%s)", moduleKey.c_str(), e.what());
		}
	});
	if (! rawInputData)
		return NULL;

	char *processedInputData;
#if VUO_PRO
	processedInputData = loadModule_Pro0(moduleInfo, moduleKey, inputDataBytes, rawInputData);
#else
	processedInputData = rawInputData;
#endif

	Module *module = NULL;
	set<string> moduleArchs;
	bool moduleParseError = !processedInputData;
	if (!moduleParseError)
	{
		string moduleReadError;
		string arch = VuoCompiler::getTargetArch(target);
		VuoLog_status("Loading module \"%s\" (%s)", moduleKey.c_str(), arch.c_str());
		module = VuoCompiler::readModuleFromBitcodeData(processedInputData, inputDataBytes, arch, moduleArchs, moduleReadError);
		VuoLog_status(NULL);
		free(processedInputData);

		if (!module)
		{
			moduleParseError = true;

			if (VuoFileUtilities::arePathsEqual(moduleInfo->getSearchPath(), getCompiledModuleCachePath()))
				deleteFromCompiledModuleCache(moduleInfo->getFile()->path());
			else
				VUserLog("Error: Couldn't load module '%s' into %s environment: %s.", moduleKey.c_str(), arch.c_str(), moduleReadError.c_str());
		}
	}

	if (!moduleParseError)
	{
		string modulePath;
		if (! moduleInfo->getFile()->isInArchive())
			modulePath = moduleInfo->getFile()->path();

		VuoCompilerCompatibility moduleCompatibility = (VuoFileUtilities::arePathsEqual(moduleInfo->getSearchPath(), getCompiledModuleCachePath()) ?
															VuoCompilerCompatibility::compatibilityWithAnySystem() :
															VuoCompilerCompatibility::compatibilityWithArchitectures(moduleArchs));

		__block VuoCompilerModule *compilerModule;
		dispatch_sync(llvmQueue, ^{
						  compilerModule = VuoCompilerModule::newModule(moduleKey, module, modulePath, moduleCompatibility);
					  });

		if (compilerModule)
		{
#if VUO_PRO
			loadModule_Pro1(rawInputData, processedInputData, compilerModule);
#endif
			return compilerModule;
		}
		else
		{
			VuoCompiler::destroyLlvmModule(module);
		}
	}

	return NULL;
}

/**
 * Attempts to add the module to this environment, replacing the old version of the module if any.
 *
 * If the LLVM module can't be loaded as a VuoCompilerModule, this function destroys the LLVM module and silently fails.
 */
void VuoCompilerEnvironment::loadInMemoryModule(const string &moduleKey, const string &moduleSourceCode,
												Module *module, std::function<void(void)> moduleLoadedCallback,
												VuoCompiler *compiler, dispatch_queue_t llvmQueue)
{
	__block VuoCompilerModule *compilerModule;
	dispatch_sync(llvmQueue, ^{
		compilerModule = VuoCompilerModule::newModule(moduleKey, module, "", VuoCompilerCompatibility::compatibilityWithAnySystem());
	});

	if (compilerModule)
		loadInMemoryModule(compilerModule, moduleSourceCode, moduleLoadedCallback, compiler, llvmQueue);
	else
		VuoCompiler::destroyLlvmModule(module);
}

/**
 * Adds the module to this environment, replacing the old version of the module if any.
 */
void VuoCompilerEnvironment::loadInMemoryModule(VuoCompilerModule *module, const string &moduleSourceCode,
												std::function<void(void)> moduleLoadedCallback, VuoCompiler *compiler,
												dispatch_queue_t llvmQueue)
{
	string moduleKey = module->getPseudoBase()->getModuleKey();

	set<string> modulesAdded;
	set<string> modulesModified;
	(findModule(moduleKey) ? modulesModified : modulesAdded).insert(moduleKey);

	if (module->getModule())
	{
		dispatch_sync(llvmQueue, ^{
			VuoCompiler::setTargetForModule(module->getModule(), target);
		});
	}

	inMemoryModuleAwaitingLoad = module;

	compiler->loadModulesAndSources(modulesAdded, modulesModified, {}, {}, {}, {}, false, false, this, nullptr, moduleLoadedCallback, moduleSourceCode);
}

/**
 * Adds a vertex representing @a module and edges for the module's dependencies to the environment's full dependency graph.
 */
void VuoCompilerEnvironment::addToDependencyGraph(VuoCompilerModule *module)
{
	VuoDependencyGraphVertex *vertex = VuoDependencyGraphVertex::vertexForDependency(module->getPseudoBase()->getModuleKey(), dependencyGraph);
	dependencyGraph->addVertex(vertex);

	vertex->setEnvironment(this);

	set<string> dependencies = module->getDependencies();
	for (set<string>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		VuoDependencyGraphVertex *depVertex = VuoDependencyGraphVertex::vertexForDependency(*i, dependencyGraph);
		dependencyGraph->addEdge(vertex, depVertex);
	}
}

/**
 * Removes the vertex representing @a module and all of its edges from the environment's full dependency graph.
 */
void VuoCompilerEnvironment::removeFromDependencyGraph(VuoCompilerModule *module)
{
	VuoDependencyGraphVertex *vertex = VuoDependencyGraphVertex::vertexForDependency(module->getPseudoBase()->getModuleKey(), dependencyGraph);
	dependencyGraph->removeVertex(vertex);
}

/**
 * Inventories the items that should be included in this environment's cache.
 *
 * @param[out] dylibsNeededToLinkToThisCache The paths of all dylibs that the module cache dylib should
 *     link to on behalf of this environment.
 * @param[out] frameworksNeededToLinkToThisCache The names of all frameworks that the cache dylib should
 *     link to on behalf of this environment.
 */
VuoModuleCacheManifest VuoCompilerEnvironment::getCacheableModulesAndDependencies(set<string> &dylibsNeededToLinkToThisCache,
																				  set<string> &frameworksNeededToLinkToThisCache)
{
	if (! isModuleCacheableDataDirty)
	{
		dylibsNeededToLinkToThisCache = this->dylibsNeededToLinkToThisCache;
		frameworksNeededToLinkToThisCache = this->frameworksNeededToLinkToThisCache;
		return cacheableModulesAndDependencies;
	}

	cacheableModulesAndDependencies = VuoModuleCacheManifest();
	VuoCompilerCompatibility compositionTargets = VuoCompilerCompatibility::compatibilityWithTargetTriple(target);

	// Include all modules…
	map<string, VuoCompilerModule *> allModules;
	allModules.insert(nodeClasses.begin(), nodeClasses.end());
	allModules.insert(types.begin(), types.end());
	allModules.insert(libraryModules.begin(), libraryModules.end());

	set<string> dependencies;
	for (map<string, VuoCompilerModule *>::iterator i = allModules.begin(); i != allModules.end(); ++i)
	{
		string moduleKey = i->first;
		VuoCompilerModule *module = i->second;

#if VUO_PRO
		// … except Pro modules and modules that depend on them…
		if (module->requiresPro())
			continue;
#endif

		// … and incompatible modules…
		if (! module->getCompatibleTargets().isCompatibleWith(compositionTargets))
			continue;

		// … and not-fully-specialized generic modules.
		if (! module->getModule())
			continue;

		VuoModuleInfo *sourceInfo = listSourceFile(moduleKey);
		bool isOverridden = sourceInfo ? sourceInfo->isSourceCodeOverridden() : false;
		cacheableModulesAndDependencies.addModule(moduleKey, isOverridden);

		set<string> moduleDependencies = module->getDependencies();
		dependencies.insert(moduleDependencies.begin(), moduleDependencies.end());
	}

	// For the built-in environment, include Vuo's core dependencies.
	if (builtIn && ! generated)
	{
		vector<string> coreDependencies = VuoCompiler::getCoreVuoDependencies();
		dependencies.insert(coreDependencies.begin(), coreDependencies.end());
	}

	// Include all dependencies of the included modules that are located in this environment.
	// (All modules are already included, so we only need to handle non-module dependencies.)
	for (set<string>::iterator i = dependencies.begin(); i != dependencies.end(); ++i)
	{
		string dependency = *i;
		if (allModules.find(dependency) == allModules.end())
		{
			if (VuoStringUtilities::endsWith(dependency, ".framework"))
				frameworksNeededToLinkToThisCache.insert(dependency);
			else
			{
				string dependencyPath = VuoCompiler::getLibraryPath(dependency, librarySearchPaths);
				if (! dependencyPath.empty())
				{
					if (VuoStringUtilities::endsWith(dependencyPath, ".dylib"))
						dylibsNeededToLinkToThisCache.insert(dependencyPath);
					else
						cacheableModulesAndDependencies.addDependency(dependency);
				}
			}
		}
	}

	this->dylibsNeededToLinkToThisCache = dylibsNeededToLinkToThisCache;
	this->frameworksNeededToLinkToThisCache = frameworksNeededToLinkToThisCache;
	return cacheableModulesAndDependencies;
}

/**
 * Call this function when cacheable modules have been added to, modified in, or removed from this environment.
 * It flags the cache as needing rebuilt.
 */
void VuoCompilerEnvironment::modulesChanged(void)
{
	isModuleCacheableDataDirty = true;

	if (moduleCache)
		moduleCache->invalidate();
}

/**
 * Returns true if this is the environment for built-in original modules.
 */
bool VuoCompilerEnvironment::isBuiltInOriginal()
{
	return builtIn && ! generated;
}

/**
 * Returns true if this environment is for built-in modules.
 */
bool VuoCompilerEnvironment::isBuiltIn()
{
	return builtIn;
}

/**
 * Returns true if this environment is for generated modules, false if for original modules.
 */
bool VuoCompilerEnvironment::isGenerated()
{
	return generated;
}

/**
 * Returns an identifier for this environment, suitable for log messages.
 */
string VuoCompilerEnvironment::getName()
{
	if (isBuiltInOriginal())
		return "builtin";
	else if (this == VuoCompiler::sharedEnvironments[target][0][1])
		return "builtin (generated)";
	else if (this == VuoCompiler::sharedEnvironments[target][1][0])
		return "system";
	else if (this == VuoCompiler::sharedEnvironments[target][1][1])
		return "system (generated)";
	else if (this == VuoCompiler::sharedEnvironments[target][2][0])
		return "user";
	else if (this == VuoCompiler::sharedEnvironments[target][2][1])
		return "user (generated)";
	else
		for (auto i : VuoCompiler::environmentsForCompositionFamily[target])
			if (std::find(i.second.begin(), i.second.end(), this) != i.second.end())
				return "composition-family";
	return "composition-local";
}
